{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2 Times New Roman;}{\f1\fswiss\fcharset0\fprq2 Arial;}{\f2\fmodern\fcharset0\fprq1 Courier New;}{\f3\froman\fcharset2\fprq2 Symbol;}{\f4\froman\fcharset0\fprq2 Times;}{\f5\fswiss\fcharset0\fprq2 Helvetica;}{\f6\fmodern\fcharset0\fprq1 Courier;}{\f7\fswiss\fcharset0\fprq2 Geneva;}{\f8\froman\fcharset0\fprq2 Tms Rmn;}{\f9\fswiss\fcharset0\fprq2 Helv;}{\f10\froman\fcharset0\fprq2 MS Serif;}{\f11\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 System;}{\f14\fnil\fcharset2\fprq2 Wingdings;}{\f15\fswiss\fcharset0\fprq2 Tahoma;}{\f16\froman\fcharset0\fprq2 CG Times (WN);}{\f17\fswiss\fcharset0\fprq2 Univers;}{\f18\fmodern\fcharset0\fprq1 LinePrinter;}{\f19\froman\fcharset0\fprq2 CG Times;}{\f20\fnil\fcharset2\fprq2 Marlett;}{\f21\fmodern\fcharset0\fprq1 Lucida Console;}{\f22\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f23\fswiss\fcharset0\fprq2 Haettenschweiler;}{\f24\fswiss\fcharset0\fprq2 Arial Black;}{\f25\froman\fcharset0\fprq2 Garamond;}{\f26\froman\fcharset2\fprq2 Bookshelf Symbol 3;}{\f27\fswiss\fcharset2\fprq2 Bookshelf Symbol 4;}{\f28\fnil\fcharset2\fprq2 Bookshelf Symbol 5;}{\f29\fnil\fcharset2\fprq2 MS Outlook;}{\f30\fscript\fcharset0\fprq2 Comic Sans MS;}{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\froman\fcharset2\fprq2 Webdings;}{\f33\fswiss\fcharset0\fprq2 AvantGarde Md BT;}{\f34\fswiss\fcharset0\fprq2 AvantGarde Bk BT;}{\f35\froman\fcharset0\fprq2 Book Antiqua;}{\f36\fnil\fcharset2\fprq2 Monotype Sorts;}{\f37\fswiss\fcharset0\fprq2 Arial Narrow;}{\f38\froman\fcharset0\fprq2 Bookman Old Style;}{\f39\fswiss\fcharset0\fprq2 Century Gothic;}{\f40\fscript\fcharset0\fprq2 Monotype Corsiva;}{\f41\froman\fcharset0\fprq2 Century Schoolbook;}{\f42\fswiss\fcharset0\fprq2 Impact;}{\f43\froman\fcharset0\fprq2 CG Times (W1) ;}{\f44\froman\fcharset238\fprq2 Times New Roman CE;}{\f45\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f47\froman\fcharset161\fprq2 Times New Roman Greek;}{\f48\froman\fcharset162\fprq2 Times New Roman Tur;}{\f49\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f50\fswiss\fcharset238\fprq2 Arial CE;}{\f51\fswiss\fcharset204\fprq2 Arial Cyr;}{\f53\fswiss\fcharset161\fprq2 Arial Greek;}{\f54\fswiss\fcharset162\fprq2 Arial Tur;}{\f55\fswiss\fcharset186\fprq2 Arial Baltic;}{\f56\fmodern\fcharset238\fprq1 Courier New CE;}{\f57\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f59\fmodern\fcharset161\fprq1 Courier New Greek;}{\f60\fmodern\fcharset162\fprq1 Courier New Tur;}{\f61\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f134\fswiss\fcharset238\fprq2 Tahoma CE;}{\f135\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f137\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f138\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f139\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f170\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f171\fmodern\fcharset204\fprq1 Lucida Console Cyr;}{\f173\fmodern\fcharset161\fprq1 Lucida Console Greek;}{\f174\fmodern\fcharset162\fprq1 Lucida Console Tur;}{\f176\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE;}{\f177\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr;}{\f179\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek;}{\f180\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur;}{\f188\fswiss\fcharset238\fprq2 Arial Black CE;}{\f189\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f191\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f192\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f193\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f194\froman\fcharset238\fprq2 Garamond CE;}{\f195\froman\fcharset204\fprq2 Garamond Cyr;}{\f197\froman\fcharset161\fprq2 Garamond Greek;}{\f198\froman\fcharset162\fprq2 Garamond Tur;}{\f199\froman\fcharset186\fprq2 Garamond Baltic;}{\f230\fswiss\fcharset238\fprq2 Verdana CE;}{\f231\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f233\fswiss\fcharset161\fprq2 Verdana Greek;}{\f234\fswiss\fcharset162\fprq2 Verdana Tur;}{\f235\fswiss\fcharset186\fprq2 Verdana Baltic;}{\f242\fswiss\fcharset238\fprq2 AvantGarde Md BT CE;}{\f245\fswiss\fcharset161\fprq2 AvantGarde Md BT Greek;}{\f246\fswiss\fcharset162\fprq2 AvantGarde Md BT Tur;}{\f248\fswiss\fcharset238\fprq2 AvantGarde Bk BT CE;}{\f251\fswiss\fcharset161\fprq2 AvantGarde Bk BT Greek;}{\f252\fswiss\fcharset162\fprq2 AvantGarde Bk BT Tur;}{\f266\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f267\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f269\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f270\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f271\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f272\froman\fcharset238\fprq2 Bookman Old Style CE;}{\f273\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f275\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f276\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f277\froman\fcharset186\fprq2 Bookman Old Style Baltic;}{\f296\fswiss\fcharset238\fprq2 Impact CE;}{\f297\fswiss\fcharset204\fprq2 Impact Cyr;}{\f299\fswiss\fcharset161\fprq2 Impact Greek;}{\f300\fswiss\fcharset162\fprq2 Impact Tur;}{\f301\fswiss\fcharset186\fprq2 Impact Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \snext0 Normal;}{\s1\sb60\sa120\keepn\nowidctlpar\widctlpar\adjustright \b\f1\fs28\cgrid \sbasedon0 \snext0 heading 1;}{\s2\li360\ri360\sb120\nowidctlpar\widctlpar\adjustright \b\f9\cgrid \sbasedon0 \snext0 heading 2;}{\s3\sb240\sa60\nowidctlpar\widctlpar\adjustright \b\f9\cgrid \sbasedon0 \snext0 heading 3;}{\s4\li360\sb120\nowidctlpar\widctlpar\adjustright \f9\ul\cgrid \sbasedon0 \snext0 heading 4;}{\s5\sb240\sa60\nowidctlpar\widctlpar\adjustright \f9\fs22\cgrid \sbasedon0 \snext0 heading 5;}{\s6\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f9\fs22\cgrid \sbasedon0 \snext0 heading 6;}{\s7\sb240\sa60\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f9\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f9\fs18\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\sb120\nowidctlpar\widctlpar\brdrt\brdrs\brdrw15\brsp20 \brdrbtw\brdrs\brdrw15\brsp20 \tqr\tx9718\adjustright \b\f1\fs18\cgrid \sbasedon0 \snext15 footer;}{\*\cs16 \additive \super \sbasedon10 footnote reference;}{\s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon0 \snext17 footnote text;}{\s18\sb120\nowidctlpar\widctlpar\tqc\tx4321\tqc\tx4859\tqr\tx8641\tqr\tx9718\adjustright \b\f1\fs18\cgrid \sbasedon0 \snext18 header;}{\s19\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon0 \snext19 Header Base;}{\s20\li720\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon0 \snext20 Normal Indent;}{\s21\li180\sb120\nowidctlpar\widctlpar\adjustright \b\f9\fs28\cgrid \sbasedon0 \snext0 Topic Caption;}{\s22\li360\sb120\nowidctlpar\widctlpar\adjustright \b\f9\cgrid \sbasedon0 \snext0 Topic Heading;}{\s23\li360\ri360\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon0 \snext23 Topic Text;}{\s24\li720\ri720\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon23 \snext24 Topic Text Indent;}{\s25\fi-360\li720\ri360\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid \sbasedon23 \snext25 Topic Text Item;}{\s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid \sbasedon0 \snext0 SubHeading;}{\s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid \sbasedon0 \snext27 Source;}{\s28\li74\ri74\sb120\sa60\nowidctlpar\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext28 TableHeading;}{\s29\li74\ri74\sb40\sa40\nowidctlpar\widctlpar\adjustright \f1\fs22\cgrid \sbasedon0 \snext29 TableText;}{\*\cs30 \additive \super \sbasedon10 endnote reference;}{\s31\nowidctlpar\widctlpar\adjustright \f2\fs16\cgrid \sbasedon27 \snext31 SourceFile;}{\s32\nowidctlpar\widctlpar\adjustright \f2\fs20\cgrid \sbasedon0 \snext32 Plain Text;}}{\*\revtbl {Unknown;}}{\info{\title ABFDLL.DLL Dynamic Link Library ABF/ATF/CVT APIs}{\author Bruce Ikin}{\operator Philip Churchward}{\creatim\yr1998\mo4\dy6\hr15}{\revtim\yr1998\mo4\dy6\hr15}{\version2}{\edmins0}{\nofpages53}{\nofwords5676}{\nofchars32355}{\*\company Axon Research}{\nofcharsws39734}{\vern71}}\margl1440\margr1080 \facingp\widowctrl\ftnbj\aenddoc\margmirror\noextrasprl\prcolbl\cvmme\sprsspbf\brkfrm\swpbdr\lytprtmet\hyphcaps0\fracwidth\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0{\*\template C:\\AL\\TEMPLATE\\ROBORTF.DOT}\sectd \pgnrestart\linex0\headery504\endnhere\sectdefaultcl {\footerl \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\field{\*\fldinst {page \\* arabic}}{\fldrslt {\lang1024 42}}}{ }{\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol"}}{\fldrslt }}{ }{\field{\*\fldinst {Styleref "Heading 1"}}{\fldrslt {\lang1024 # $ K ABFH_CheckUserList}}}{\tab }{\field{\*\fldinst {Title}}{\fldrslt {ABFDLL.DLL Dynamic Link Library ABF/ATF/CVT APIs}}}{
\par }}{\footerr \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\field{\*\fldinst {Title}}{\fldrslt {ABFDLL.DLL Dynamic Link Library ABF/ATF/CVT APIs}}}{\tab }{\field{\*\fldinst {Styleref "Heading 1"}}{\fldrslt {\lang1024 # $ K + ABFINFO.H}}}{ }{\field\flddirty{\*\fldinst {SYMBOL 183 \\f "Symbol"}}{\fldrslt }}{ }{\field{\*\fldinst {page \\* arabic}}{\fldrslt {\lang1024 53}}}{
\par }}{\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_ClipADCUUValue}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_ClipADCUUValue}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_ClipADCUUValue}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_ClipADCUUValue
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "}{\b\f1\uldb\cf11 abfheadr.h}{\b\v\f1 ABFHEADR_H}{\b\f1 "}{\f1 
{\v0\par\v}}{\b\f1 int ABFH_ClipADCUUValue( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int }{\i\f1 nChannel}{\f1 ,\line \tab }{\b\f1 float}{\f1  }{\i\f1 *pfUUValue }{\f1 );
{\v0\par\v}}\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Limits the UU value to the range of the }{\f1\ul\cf11 A/D}{\v\f1 ADC_A_D}{\f1  converter.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uChannel}{\f1 \cell Physical }{\f1\ul\cf11 ADC}{\v\f1 ADC_A_D}{\f1  channel number corresponding to the UU value.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUValue}{\f1 \cell Passes in and returns the clipped UserUnit value.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "}{\f1\uldb\cf11 abfheadr.h}{\v\f1 ABFHEADR_H}{\f1 \rdblquote 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_ClipDACUUValue}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_ClipDACUUValue}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_ClipDACUUValue}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_ClipDACUUValue
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }{\b\f1 int ABFH_ClipDACUUValue( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int }{\i\f1 nChannel}{\f1 ,\line \tab }{\b\f1 float}{\f1  }{\i\f1 *pfUUValue }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Limits the UU value to the range of the }{\f1\ul\cf11 D/A}{\v\f1 DAC_D_A}{\f1  converter.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uChannel}{\f1 \cell Physical DAC channel number corresponding to the UU value.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUValue}{\f1 \cell Passes in and returns the clipped UserUnit value.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetADCtoUUFactors}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetADCtoUUFactors}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetADCtoUUFactors}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetADCtoUUFactors
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }{\b\f1 void ABFH_GetADCtoUUFactors( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int }{\i\f1 nChannel}{\f1 ,\line \tab }{\b\f1 float}{\f1  }{\i\f1 *pfADCToUUFactor}{\f1 , }{\b\f1 float}{\f1  *}{\i\f1 pfADCToUUShift }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Calculates the scaling factors used to convert }{\f1\ul\cf11 ADC}{\v\f1 ADC_A_D}{\f1  values to UserUnits.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell Physical ADC channel number to get the factors for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfADCToUUFactor}{\f1 \cell Returns the multiplier used in the conversion.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfADCToUUShift}{\f1 \cell Returns the offset used in the conversion.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_GetADCtoUUFactors}{\f1  function can be called to obtain two factors for converting ADC values to "User Units" and vice versa. The factors are used as follows:
\par UU = ADCValue * fADCtoUUFactor + fADCtoUUShift;
\par or
\par ADCValue = (UU - fADCtoUUShift) / fADCtoUUFactor;
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h\rdblquote 
\par void ShowADCValues(ABFFileHeader *pFH, UINT uChannel,
\par                    short *pnADCValues, UINT uCount) 
\par \{
\par    UINT i;
\par    float }{\i fADCtoUUFactor}{, }{\i fADCtoUUShift;}{
\par    ABFH_GetADCtoUUFactors( pFH, uChannel, &fADCtoUUFactor, 
\par                            &fADCtoUUShift );
\par 
\par    for (i=0; i<uCount; i++)
\par    \{
\par       fUU = *pnADCValues++ * fADCtoUUFactor + fADCtoUUShift;
\par       printf("%g", fUU);
\par    \}
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetADCDisplayRange}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetADCDisplayRange}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetADCDisplayRange}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetADCDisplayRange
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "}{\b\f1\uldb\cf11 abfheadr.h}{\b\v\f1 ABFHEADR_H}{\b\f1 "}{\f1 
{\v0\par\v}}{\b\f1 void ABFH_GetADCDisplayRange( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int }{\i\f1 nChannel}{\f1 ,\line \tab }{\b\f1 float}{\f1  }{\i\f1 *pfUUTop}{\f1 , }{\b\f1 float}{\f1  *}{\i\f1 pfUUBottom }{\f1 );
{\v0\par\v}}\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Calculates the upper and lower limits of the display given the display amplification and offset in the ABF header for this channel.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell Physical }{\f1\ul\cf11 ADC}{\v\f1 ADC_A_D}{\f1  channel number to get the display limits for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUTop}{\f1 \cell Returns the UserUnit value of the top of the display.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUBottom}{\f1 \cell Returns the UserUnit value of the bottom of the display.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h\rdblquote 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetDACtoUUFactors}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetDACtoUUFactors}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetDACtoUUFactors}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetDACtoUUFactors
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }{\b\f1 void ABFH_GetDACtoUUFactors( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int }{\i\f1 nChannel}{\f1 ,\line \tab }{\b\f1 float}{\f1  }{\i\f1 *pfDACToUUFactor}{\f1 , }{\b\f1 float}{\f1  *}{\i\f1 pfDACToUUShift }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Calculates the scaling factors used to convert DAC values to }{\f1\ul\cf11 UserUnits}{\v\f1 User_Units}{\f1 .
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell DAC channel number to get the factors for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfDACToUUFactor}{\f1 \cell Returns the multiplier used in the conversion.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfDACToUUShift}{\f1 \cell Returns the offset used in the conversion.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_GetDACtoUUFactors}{\f1  function can be called to obtain two factors for converting DAC values to "User Units" and vice versa. The factors are used as follows:
\par UU = DACValue * fDACtoUUFactor + fDACtoUUShift;
\par or
\par DACValue = (UU - fDACtoUUShift) / fDACtoUUFactor;
\par 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h\rdblquote 
\par void ShowDACValues(ABFFileHeader *pFH, UINT uChannel, 
\par                    short *pnADCValues, UINT uCount) 
\par \{
\par    UINT i;
\par    float }{\i fDACtoUUFactor}{, }{\i fDACtoUUShift;}{
\par    ABFH_GetDACtoUUFactors( pFH, uChannel, &fDACtoUUFactor,
\par                           &fDACtoUUShift );
\par 
\par    for (i=0; i<uCount; i++)
\par    \{
\par       fUU = *pnDACValues++ * fDACtoUUFactor + fDACtoUUShift;
\par       printf("%g", fUU);
\par    \}
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetMathValue}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetMathValue}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetMathValue}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetMathValue
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetMathValue(ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 float }{\i\f1 fA}{\f1 , }{\b\f1 float}{\f1  }{\i\f1 fB}{\f1 , \line \tab }{\b\f1 float *}{\i\f1 pfRval}{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Takes two floating point values and combines them according to the Math Channel equation and constants contained in the ABF header.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the math channel parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fA}{\f1 \cell Value for channel A\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fB}{\f1 \cell Value for channel B\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfRval\cell }{\f1 Points to the location in which to return the result of the combination of fA & fB.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_GetMathValue}{\f1  function is called internally by ABF_ReadChannel() when a channel number of -1 is passed - signifying the math channel is to be read.
\par Returns
\par TRUE is returned if the expression could be evaluated OK.\line FALSE is returned if a divide by zero occurred while evaluation the expression.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetErrorText}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetErrorText}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetErrorText}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetErrorText
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "}{\b\f2 abfheadr.h\rdblquote }{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 int ABFH_GetErrorText( int}{\f1  }{\i\f1 nError}{\f1 , }{\b\f1 char *}{\i\f1 pszBuffer}{\f1 , }{\b\f1 int}{\f1  }{\i\f1 nBufferSize}{\f1  }{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Builds an error description string for a given ABFH_ error number.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nError}{\f1 \cell The error number of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pszBuffer}{\f1 \cell A character buffer to fill with the error message.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nBufferSize}{\f1 \cell The size in characters of the buffer passed as pszBuffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 ABFH_GetErrorText}{\f1  should only be used to build error messages from error numbers returned by ABFH_XXXX functions
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The length of the string placed in the passed buffer is returned. If an invalid error number is passed in, or there is no string available for it, 0 is returned.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "}{\uldb\cf11 abfheadr.h}{\v ABFHEADR_H}{\rdblquote 
{\v0\par\v}
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetEpochLimits}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetEpochLimits}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetEpochLimits}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetEpochLimits
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetEpochLimits(ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int}{\f1  }{\i\f1 nChannel}{\f1 , \line \tab }{\b\f1 DWORD}{\f1  }{\i\f1 dwEpisode}{\f1 , }{\b\f1 int}{\f1  }{\i\f1 nEpoch}{\f1 , }{\b\f1 UINT}{\f1  *}{\i\f1 puEpochStart}{\f1 , \line \tab }{\b\f1 UINT}{\f1  *}{\i\f1 puEpochEnd}{\f1 , }{\b\f1 int}{\f1  *}{\i\f1 pnError}{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetEpochLimits}{\f1  is used to retreive information for a particular epoch in a particular }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  of the output waveform.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the waveform epoch definitions.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dwEpisode\cell }{\f1 The sweep for which to calculate the epoch position.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nEpoch\cell }{\f1 The epoch number for which to calculate the start & finish point. Epochs are numbered from 0-9. The limits of the first and last holding regions may also be returned by passing ABFH_FIRSTHOLDING or ABFH_LASTHOLDING as the epoch number.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 puEpochStart\cell }{\f1 Points to location in which to return the starting offset of the epoch.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 puEpochEnd\cell }{\f1 Points to location in which to return the ending offset of the epoch.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The epoch start and end positions are calculated as }{\f1\ul\cf11 sample}{\v\f1 Sample}{\f1  offsets into the multiplexed }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  data.
{\v0\par\v}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_CHANNELNOTSAMPLED\cell }{\f1 The requested sample is not present in the sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EPOCHNOTPRESENT\cell }{\f1 The requested epoch is not present in the sweep specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetChannelOffset}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetChannelOffset}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetChannelOffset}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetChannelOffset
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetChannelOffset( ABFFileHeader}{\f1  *}{\i\f1 pFH}{\f1 , }{\b\f1 int}{\f1  }{\i\f1 nChannel}{\f1 , \line \tab }{\b\f1 UINT}{\f1  *}{\i\f1 puChannelOffset}{\f1  );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetEpochLimits}{\f1  is used to convert an }{\f1\ul\cf11 ADC}{\v\f1 ADC_A_D}{\f1  channel number into an offset into the multiplexed data stream.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the channel mapping and sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 puChannelOffset\cell }{\f1 Points to location in which to return the offset to the data for this channel.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 TRUE is returned if the offset is found OK.\line FALSE is returned if the requested channel is not in the sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .
{\v0\par\v}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetWaveform}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetWaveform}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetWaveform}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetWaveform
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetWaveform( ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 int}{\f1  }{\i\f1 nChannel}{\f1 , \line \tab }{\b\f1 DWORD}{\f1  }{\i\f1 dwEpisode}{\f1 , }{\b\f1 float}{\f1  *}{\i\f1 pfBuffer}{\f1 , }{\b\f1 int}{\f1  *}{\i\f1 pnError}{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetWaveform}{\f1  fills a buffer with the values that correspond to the DAC values output at the same time that a particular ADC channel was being sampled.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the waveform epoch definitions.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular ADC channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dwEpisode\cell }{\f1 The sweep}{\v\f1 p}{\f1  for which build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfBuffer\cell }{\f1 Points to a buffer to fill with the waveform (in DAC }{\f1\ul\cf11 UserUnits}{\v\f1 User_Units}{\f1 ).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The waveform built is the waveform that corresponds to a particular ADC channel, and hence the length of the waveform returned is\line pFH->lNumSamplesPerEpisode / pFH->nADCNumChannels.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOWAVEFORM\cell }{\f1 Either there was no waveform specificication in the header, or the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  number is out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EDACFILEWAVEFORM\cell }{\f1 The waveform was taken from a DAC file, not from epoch definitions in the header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOMEMORY\cell }{\f1 Insufficient memory is available for a temporary buffer needed to  build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_CHANNELNOTSAMPLED\cell }{\f1 The requested }{\f1\ul\cf11 sample}{\v\f1 Sample}{\f1  is not present in the sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\uldb\cf11 ABFH_GetWaveformVector}{\v ABFH_GetWaveformVector}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetWaveformVector}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetWaveformVector}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetWaveformVector}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetWaveformVector
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetWaveformVector(ABFFileHeader *}{\i\f1 pFH}{\f1 , \line \tab }{\b\f1 DWORD}{\f1  }{\i\f1 dwEpisode}{\f1 , }{\b\f1 UINT}{\f1  }{\i\f1 uStart}{\f1 , }{\b\f1 UINT}{\f1  }{\i\f1 uFinish}{\f1 , }{\b\f1 float}{\f1  *}{\i\f1 pfLevels}{\f1 , \line \tab }{\b\f1 float}{\f1  *}{\i\f1 pfTimes}{\f1 , }{\b\f1 int}{\f1  *}{\i\f1 pnVectors}{\f1 , }{\b\f1 int}{\f1  *}{\i\f1 pnError}{\b\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetWaveformVector}{\f1  builds a description of the output waveform as a set of Level/Time pairs.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the waveform epoch definitions.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dwEpisode\cell }{\f1 The }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  for which build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uStart\cell }{\f1 The vectors will be clipped to start at this time.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uFinish\cell }{\f1 The vectors will be clipped to finish at this time.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfLevels\cell }{\f1 Pointer to an array ABFH_MAXVECTORS long of }{\v\f1 floatfloats }{\f1 to receive the level components.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfTimes\cell }{\f1 Pointer to an array ABFH_MAXVECTORS long of floats to receive the time components.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnVectors\cell }{\f1 Points to location in which to return the number of vectors generated.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOWAVEFORM\cell }{\f1 Either there was no waveform specificication in the header, or the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  number is out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EDACFILEWAVEFORM\cell }{\f1 The waveform was taken from a DAC file, not from epoch definitions in the header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1\uldb\cf11 ABFH_GetWaveform}{\v\f1 ABFH_GetWaveform}{\f1  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetTimebase}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetTimebase}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetTimebase}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetTimebase
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 void ABFH_GetTimebase(ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 float}{\f1  }{\i\f1 fTimeOffset}{\f1 , \line \tab }{\b\f1 float}{\f1  *}{\i\f1 pfBuffer}{\f1 , }{\b\f1 UINT }{\i\f1 uBufferSize}{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetTimebase}{\f1  builds a time array from the sampling rate parameters in the ABF header.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the sampling rate parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fTimeOffset\cell }{\f1 An offset that is added to all generated time values. This may be used to adjust the time array so that the first epoch starts at 0.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfBuffer\cell }{\f1 Points to a floating point buffer to fill with values.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uBufferSize\cell }{\f1 To get the complete timebase for the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  the size of the buffer should be\line }{\f1\ul pFH->lNumSamplesPerEpisode}{\f1 \line pFH->nADCNumChannels.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetTimebaseEx}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetTimebaseEx}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetTimebaseEx}}}{ }{\cs16\super +{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetTimebaseEx
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 void ABFH_GetTimebaseEx(ABFFileHeader *}{\i\f1 pFH}{\f1 , }{\b\f1 double}{\f1  }{\i\f1 dTimeOffset}{\f1 , \line \tab }{\b\f1 double __huge *}{\i\f1 pdBuffer}{\f1 , }{\b\f1 UINT }{\i\f1 uBufferSize}{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetTimebaseEx}{\f1  builds a time array from the sampling rate parameters in the ABF header.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the sampling rate parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dTimeOffset\cell }{\f1 An offset that is added to all generated time values. This may be used to adjust the time array so that the first epoch starts at 0.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pdBuffer\cell }{\f1 Points to a buffer to fill with values.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uBufferSize\cell }{\f1 To get the complete timebase for the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  the size of the buffer should be\line }{\f1\ul pFH->lNumSamplesPerEpisode}{\f1 \line pFH->nADCNumChannels.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetHoldingDuration}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetHoldingDuration}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetHoldingDuration}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_GetHoldingDuration
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 UINT ABFH_GetHoldingDuration(ABFFileHeader}{\f1  *}{\i\f1 pFH}{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetHoldingDuration}{\f1  returns the number of points that make up the first holding section of the waveform.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The number of }{\v\f1 sampleSamples }{\f1 that make up the first holding region will be returned.
{\v0\par\v}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_IsConstantWaveform}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_IsConstantWaveform}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_IsConstantWaveform}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_IsConstantWaveform
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_IsConstantWaveform(ABFFileHeader *}{\i\f1 pFH}{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_IsConstantWaveform}{\f1  checks to see if the waveform specification in the ABF header contains any varying epochs.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 TRUE is returned if the waveform does not have any varying epoch specifications.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 #include "abfheadr.h\rdblquote 
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_Initialize}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_Initialize}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_Initialize}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_Initialize
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h "}{\f1 
\par }{\b\f1 void ABFH_Initialize(}{\f1  }{\b\f1 ABFFileHeader *}{\i\f1 pFH }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Initialises an ABFFileHeader structure to contain a minimum consistent set of parameters.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to an ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_Initialize}{\f1  function may be used to initialise an ABFFileHeader structure. All strings will be space filled, all gains set to 1.0, and all offsets set to 0.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h"
\par ABFFileHeader FH; 
\par ABFH_Initialize(&FH)
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_InitializeScopeConfig}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_InitializeScopeConfig}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_InitializeScopeConfig}}}{ }{\cs16\super +{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_InitializeScopeConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b void ABFH_InitializeScopeConfig(ABFFileHeader *}{\i pFH}{, }{\b ABFScopeConfig *}{\i pCfg}{)
\par Sets up a scope configuration structure from the old header locations for display parameters.
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_CheckScopeConfig}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_CheckScopeConfig}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_CheckScopeConfig}}}{ }{\cs16\super +{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_CheckScopeConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b void ABFH_CheckScopeConfig(ABFFileHeader *}{\i pFH}{, }{\b ABFScopeConfig *}{\i pCfg}{)
\par Checks a scope configuration structure against an ABFFileHeader structure, making sure that both reference the same signals, in the same multiplex }{\ul\cf11 sequence}{\v Sequence}{.
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_ParamReader}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_ParamReader}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_ParamReader}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_ParamReader
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h "}{\f1 
\par }{\b\f1 BOOL ABFH_ParamReader( int}{\f1  }{\i\f1 hFile}{\f1 , }{\b\f1 ABFFileHeader *}{\i\f1 pFH, }{\b\f1 int *}{\i\f1 pnError }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Reads a parameter structure from an ABF }{\f1\ul\cf11 file}{\v\f1 File}{\f1 , translating old file headers into an equivalent ABFFileHeader structure.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 hFile}{\f1 \cell }{\b\f1 DOS}{\f1  file handle  <== N.B.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure to receive  parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_ParamReader}{\f1  function is called internally by }{\f1\uldb\cf11 ABF_ReadOpen}{\v\f1 ABF_ReadOpen}{\f1  when an existing ABF file is opened for reading.
{\v0\par\v}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EHEADERREAD\cell }{\f1 End of file or disk error during header read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EINVALIDFILE\cell }{\f1 Invalid DOS file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EUNKNOWNFILETYPE\cell }{\f1 File is not an ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "}{\uldb\cf11 abfheadr.h}{\v ABFHEADR_H}{\rdblquote 
{\v0\par\v}BOOL ReadABFHeader(char *szFileName, ABFFileHeader *pFH) 
{\v0\par\v}\{
{\v0\par\v}   int nFile = open(szFileName, O_BINARY, O_READONLY);
{\v0\par\v}   if (nFile < 0)
{\v0\par\v}      return FALSE;
{\v0\par\v}
{\v0\par\v}   int nError = 0;
{\v0\par\v}   if (!ABFH_ParamReader( nFile, pFH, &nError ))
{\v0\par\v}      return ShowABFHError(nError);
{\v0\par\v}
{\v0\par\v}   close(nFile);
{\v0\par\v}   return TRUE;
{\v0\par\v}\}
{\v0\par\v}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1\uldb\cf11 ABFH_ParamWriter}{\v\f1 ABFH_ParamWriter}{\f1  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_ParamWriter}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_ParamWriter}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_ParamWriter}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFH_ParamWriter
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include " abfheadr.h "}{\f1 
\par }{\b\f1 BOOL ABFH_ParamWriter( int}{\f1  }{\i\f1 hFile}{\f1 , }{\b\f1 ABFFileHeader *}{\i\f1 pFH, }{\b\f1 int *}{\i\f1 pnError }{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Writes a parameter structure to an ABF }{\f1\ul\cf11 file}{\v\f1 File}{\f1 .
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 hFile}{\f1 \cell }{\b\f1 DOS}{\f1  file handle  <== N.B.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure to receive  parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 ABFH_ParamWriter}{\f1  function is called internally by ABF_WriteOpen(), and ABF_UpdateHeader() to write an ABFFileHeader structure to a file.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EHEADERWRITE\cell }{\f1 Disk full or disk error during header write.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EINVALIDFILE\cell }{\f1 Invalid DOS file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "}{\b\f1  }{abfheadr.h\rdblquote 
\par BOOL WriteABFHeader(char *szFileName, ABFFileHeader *pFH) 
\par \{
\par    int nFile = open(szFileName, O_BINARY, O_WRITEONLY);
\par    if (nFile < 0)
\par       return FALSE;
\par 
\par    int nError = ABFH_ParamWriter( nFile, pFH );
\par    close(nFile);
\par 
\par    return (nError == ABFH_SUCCESS);
\par \}
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1\uldb\cf11 ABFH_ParamReader}{\v\f1 ABFH_ParamReader}{\f1  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetDigitalWaveform}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetDigitalWaveform}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetDigitalWaveform}}}{ ABFH_GetDigitalWaveform
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_GetDigitalWaveform}{( }{\b const ABFFileHeader}{ *pFH, }{\b int}{ nChannel, }{\b DWORD}{ dwEpisode, }{\b DWORD}{ *pdwBuffer, }{\b int}{ *pnError)
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 The function }{\b\f1 ABFH_GetDigitalWaveform}{\f1  fills a buffer with the values that correspond to the digital values output at the same time that a particular ADC channel was being sampled.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the waveform epoch definitions.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular ADC channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dwEpisode\cell }{\f1 The sweep}{\v\f1 p}{\f1  for which build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfBuffer\cell }{\f1 Points to a buffer to fill with the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The waveform built is the waveform that corresponds to a particular ADC channel, and hence the length of the waveform returned is\line pFH->lNumSamplesPerEpisode / pFH->nADCNumChannels.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOWAVEFORM\cell }{\f1 Either there was no waveform specificication in the header, or the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  number is out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOMEMORY\cell }{\f1 Insufficient memory is available for a temporary buffer needed to  build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_CHANNELNOTSAMPLED\cell }{\f1 The requested }{\f1\ul\cf11 sample}{\v\f1 Sample}{\f1  is not present in the sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetMathChannelName}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetMathChannelName}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetMathChannelName}}}{ ABFH_GetMathChannelName
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL ABFH_GetMathChannelName(char *}{\i\f1 pszName,}{\f1  }{\b UINT}{ uNameLen}{\b\f1 );}{\f1 
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Gets the name to be used when displaying the math channel. 
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pszName}{\f1 \cell Name of the math channel.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uNameLen}{\f1 \cell Length of string\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_CheckSampleIntervals}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_CheckSampleIntervals}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_CheckSampleIntervals}}}{ ABFH_CheckSampleIntervals
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_CheckSampleIntervals}{(}{\b const ABFFileHeader}{ *pFH, }{\b float}{ fClockResolution, }{\b int}{ *pnError);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Checks that the sample intervals in the header are valid.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure containing the waveform epoch definitions.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fClockResolution}{\f1 \cell The digitizer clock resolution.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pnError\cell }{\f1 Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 One of the following constants (defined in }{\f1\uldb\cf11 ABFHEADR.H}{\v\f1 ABFHEADR_H}{\f1 ).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx7740\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx7740\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOWAVEFORM\cell }{\f1 There was no waveform specification in the header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_BADSAMPLEINTERVALS\cell }{\f1 The first sample interval is not valid.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx7740\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_BADSECONDSAMPLEINTERVAL\cell }{\f1 The second sample interval is not valid.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetClosestSampleIntervals}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetClosestSampleIntervals}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetClosestSampleIntervals}}}{ ABFH_GetClosestSampleIntervals
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_GetClosestSampleIntervals}{(}{\b float}{ fSampleInterval, }{\b float}{ fClockResolution, }{\b int}{ nOperationMode, }{\b float}{ fMinPeriod, }{\b float}{ fMaxPeriod, }{\b float}{ *pfHigher, }{\b float}{ *pfLower);
\par Checks that the sample intervals in the header are valid.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fSampleInterval}{\f1 \cell The requested sample interval.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fClockResolution}{\f1 \cell The digitizer clock resolution.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nOperationMode\cell }{\f1 The acquisition mode.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fMinPeriod\cell }{\f1 The digitizer minimum sample interval.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fMaxperiod\cell }{\f1 The digitizer maximum sample interval.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfHigher\cell }{\f1 Sampling interval higher than requested.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfLower\cell }{\f1 Sampling interval lower than requested.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_SetupSamplingList}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_SetupSamplingList}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_SetupSamplingList}}}{ ABFH_SetupSamplingList
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_SetupSamplingList}{(}{\b UINT}{ uNumChannels, }{\b float}{ fMinPeriod, }{\b float}{ fMaxPeriod, }{\b float}{ *pfIntervalList, }{\b UINT}{ uListEntries);
\par 
\par Sets up the list of possible sampling intervals.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uNumChannels}{\f1 \cell The number of channels being sampled\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fMinPeriod\cell }{\f1 The digitizer minimum sample interval.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fMaxperiod\cell }{\f1 The digitizer maximum sample interval.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfIntervalList\cell }{\f1 The list of sample intervals.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uListEntries\cell }{\f1 The number of entries in the list.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_SweepLenFromUserLen}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_SweepLenFromUserLen}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_SweepLenFromUserLen}}}{ ABFH_SweepLenFromUserLen
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_SweepLenFromUserLen}{(}{\b int}{ nUserLength, }{\b int}{ nNumChannels); 
\par Get the full sweep length given the length available to epochs.
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard\plain \sb240\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nUserLength}{\f1 \cell The number of samples available to epochs\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nNumChannels\cell }{\f1 The number of channels be acquired\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_UserLenFromSweepLen}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_UserLenFromSweepLen}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_UserLenFromSweepLen}}}{ ABFH_UserLenFromSweepLen
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_UserLenFromSweepLen}{ (}{\b int}{ nUserLength, }{\b int}{ nNumChannels); 
\par Get the length available to epochs given the full sweep length.
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard\plain \sb240\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nUserLength}{\f1 \cell The number of samples available to epochs\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nNumChannels\cell }{\f1 The number of channels be acquired\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GainOffsetToDisplayRange}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GainOffsetToDisplayRange}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GainOffsetToDisplayRange}}}{ ABFH_GainOffsetToDisplayRange
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_GainOffsetToDisplayRange}{( }{\b const ABFFileHeader}{ *pFH, }{\b int}{ nChannel, }{\b float}{ fDisplayGain, }{\b float}{ fDisplayOffset, }{\b float}{ *pfUUTop, }{\b float}{ *pfUUBottom);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Converts a gain and offset to the equivalent display range.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular ADC channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fDisplayGain\cell }{\f1 The gain\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fDisplayOffset\cell }{\f1 The offset\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUTop\cell }{\f1 Pointer to the maximum user units display value\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pfUUBottom\cell }{\f1 Pointer to the minimum user units display value\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_DisplayRangeToGainOffset}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_DisplayRangeToGainOffset}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_DisplayRangeToGainOffset}}}{ ABFH_DisplayRangeToGainOffset
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_GainOffsetToDisplayRange}{( }{\b const ABFFileHeader}{ *pFH, }{\b int}{ nChannel, }{\b float}{ fDisplayGain, }{\b float}{ fDisplayOffset, }{\b float}{ *pfUUTop, }{\b float}{ *pfUUBottom);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Converts a display range to the equivalent gain and offset factors.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nChannel}{\f1 \cell The particular ADC channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fUUTop\cell }{\f1 The maximum user units display value.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 fUUBottom\cell }{\f1 The minimum user units display value. \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {pfUUTop}{\i\f1 \cell }{\f1 Pointer to the gain\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {pfUUBottom}{\i\f1 \cell }{\f1 Pointer to the offset\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_SynchCountToMS}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_SynchCountToMS}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_SynchCountToMS}}}{ ABFH_SynchCountToMS
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_SynchCountToMS}{(}{\b const ABFFileHeader}{ *pFH, }{\b UINT}{ uCount, }{\b double}{ *pdTimeMS);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Converts a synch count to a time value in ms.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uCount}{\f1 \cell The synch count to convert\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pdTimeMS\cell }{\f1 The time in ms that the synch count refers to.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_MSToSynchCount}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_MSToSynchCount}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_MSToSynchCount}}}{ ABFH_MSToSynchCount
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 UINT ABFH_MSToSynchCount(const ABFFileHeader }{\f1 *pFH}{\b\f1 , double }{\f1 dTimeMS}{\b\f1 )
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Converts a time value (in ms) to a synch count.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 dTimeMS\cell }{\f1 The time to convert\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetClockChange}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetClockChange}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetClockChange}}}{ ABFH_GetClockChange
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b UINT}{ }{\b ABFH_GetClockChange}{(}{\b const ABFFileHeader}{ *pFH);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Get the point (in multiplexed samples) at which the sampling interval changes if split clock.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetEpisodeDuration}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetEpisodeDuration}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetEpisodeDuration}}}{ ABFH_GetEpisodeDuration
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 BOOL }{\b ABFH_SynchCountToMS}{(}{\b const ABFFileHeader}{ *pFH, }{\b UINT}{ uCount, }{\b double}{ *pdTimeMS);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Gets the duration of the Waveform Episode (in us), allowing for split clock etc.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pdEpisodeDuration\cell }{\f1 Pointer to the episode duration\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetPNDuration}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetPNDuration}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetPNDuration}}}{ ABFH_GetPNDuration
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void}{ }{\b ABFH_GetPNDuration}{(}{\b const ABFFileHeader}{ *pFH, }{\b double}{ *pdPNDuration);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Gets the duration of a P/N sequence (in }{{\field{\*\fldinst SYMBOL 109 \\f "Symbol" \\s 10}{\fldrslt\f3\fs20\'6d}}}{s), including settling times.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pdPNDuration\cell }{\f1 Pointer to the duration of the P/N sequence.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetTrainDuration}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetTrainDuration}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetTrainDuration}}}{ ABFH_GetTrainDuration
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void}{ }{\b ABFH_GetTrainDuration}{(}{\b const ABFFileHeader}{ *pFH, }{\b double}{ *pdTrainDuration);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Gets the duration of a conditioning train in }{{\field{\*\fldinst SYMBOL 109 \\f "Symbol" \\s 10}{\fldrslt\f3\fs20\'6d}}}{s.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard\plain \s17\sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {pdTrainDuration}{\i\f1 \cell }\pard\plain \sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Pointer to the duration of the conditioning train.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetMetaEpisodeDuration}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetMetaEpisodeDuration}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetMetaEpisodeDuration}}}{ ABFH_GetMetaEpisodeDuration
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void}{ }{\b ABFH_GetMetaEpisodeDuration}{(}{\b const ABFFileHeader}{ *pFH, }{\b double}{ *pdMetaEpisodeDuration);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Gets the duration of a whole meta-episode (in }{{\field{\*\fldinst SYMBOL 109 \\f "Symbol" \\s 10}{\fldrslt\f3\fs20\'6d}}}{s).
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard\plain \s17\sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {pdMetaEpisodeDuration}{\i\f1 \cell }\pard\plain \sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Pointer to the duration of the meta-episode.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_GetEpisodeStartToStart}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_GetEpisodeStartToStart}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_GetEpisodeStartToStart}}}{ ABFH_GetEpisodeStartToStart
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void}{ }{\b ABFH_GetEpisodeStartToStart}{(}{\b const ABFFileHeader}{ *pFH, }{\b double}{ *pdEpisodeStartToStart);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Gets the start to start period for the episode in }{{\field{\*\fldinst SYMBOL 109 \\f "Symbol" \\s 10}{\fldrslt\f3\fs20\'6d}}}{s.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard\plain \s17\sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {pdEpisodeStartToStart}{\i\f1 \cell }\pard\plain \sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Pointer to the episode start to start period.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFH_CheckUserList}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFH_CheckUserList}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFH_CheckUserList}}}{ ABFH_CheckUserList
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfheadr.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABFH_CheckUserList}{(}{\b const ABFFileHeader}{ *pFH, }{\b int}{ *pnError);
\par }\pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {Checks that the user list contains valid entries for the protocol.
\par 
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2250\clvertalt\cltxlrtb \cellx6476\pard\plain \s17\sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {pnError}{\i\f1 \cell }\pard\plain \sb120\nowidctlpar\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Pointer to an error code.  May be NULL\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ Error_Values}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ Error Values}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ Error Values}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ Error Values
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The following is a table of error values that may be returned by functions in the ABFH_XXX set of functions.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EHEADERREAD\cell }{\f1 An error occurred while reading the header (EOF).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EHEADERWRITE\cell }{\f1 An error occurred while writing the header (Out of disk space)\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EINVALIDFILE\cell }{\f1 The header version number of this file is invalid.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EUNKNOWNFILETYPE\cell }{\f1 The file is not an ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EPOCHNOTPRESENT\cell }{\f1 The requested epoch was not present for the }{\f1\ul\cf11 sweep}{\v\f1 Sweep}{\f1  specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOWAVEFORM\cell }{\f1 Either there was no waveform specificication in the header, or the sweep number is out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_EDACFILEWAVEFORM\cell }{\f1 The waveform was taken from a }{\f1\ul\cf11 DAC}{\v\f1 DAC_D_A}{\f1  file, not from epoch definitions in the header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_ENOMEMORY\cell }{\f1 Insufficient memory is available for a temporary buffer needed to  build the waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3216\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 ABFH_CHANNELNOTSAMPLED\cell }{\f1 The requested }{\f1\ul\cf11 sample}{\v\f1 Sample}{\f1  is not present in the sampling }{\f1\ul\cf11 sequence}{\v\f1 Sequence}{\f1 .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ The_ABF_File_Information_Functions_by_category}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ The ABF File Information Functions by category}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ The ABF File Information Functions by category}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ The ABF File Information Functions
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The ABF information functions provide a way to get a textual description of an ABFFileHeader structure.  A \ldblquote C\rdblquote  definition of these functions may be found in the file }{\f1\uldb\cf11 ABFINFO.H}{\v ABFINFO_H}{\f1 .
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1\uldb\cf11 INFO_GetBufferSize}{\b\v\f1 INFO_GetBufferSize}{\b\f1 \cell }{\f1 Get the size of the buffer required by INFO_GetInfo for a particular header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\f1\uldb\cf11 INFO_GetInfo}{\b\v\f1 INFO_GetInfo}{\b\f1 \cell }{\f1 Fill a passed buffer with a textual version of information contained in an ABF header. Options are terse, long or verbose.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\uldb\cf11 ABFINFO.H}{\v ABFINFO_H}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ INFO_GetBufferSize}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ INFO_GetBufferSize}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ INFO_GetBufferSize}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ INFO_GetBufferSize
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfinfo.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 UINT INFO_GetBufferSize}{\f1 ( }{\b\f1 ABFFileHeader}{\f1  *}{\i\f1 pFH}{\f1 , }{\b\f1 char}{\f1  *}{\i\f1 szDataFile}{\f1 , \line \tab }{\b\f1 int}{\f1  }{\i\f1 nDisplayMode}{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Returns the size (in characters) of the buffer required by INFO_GetInfo with the same parameters.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure to be described.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pszFileName}{\f1 \cell String containing the name of the file associated with the ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nDisplayMode}{\f1 \cell Flag to specify the type of information required: Valid flags are: INFO_TERSE, INFO_LONG, INFO_VERBOSE.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The parameters passed into INFO_GetBufferSize must be passed unchanged into INFO_GetInfo for the buffer size returned by INFO_GetBufferSize to be valid. If parameters are changed (different file name, or midified header) the buffer size will not necessarily correspond to that required by INFO_GetInfo, resulting in truncated information.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The number of characters that will be written by INFO_GetInfo when passed the identical parameters.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h"
\par #include "abfinfo.h"
\par BOOL ShowABFFileInfo(char *szFileName) 
\par \{
\par    ABFFileHeader FH;
\par    int nFile = open(szFileName, O_BINARY, O_READONLY);
\par    if (nFile < 0)
\par       return FALSE;
\par 
\par    int nError = ABFH_ParamReader( nFile, &FH );
\par    close(nFile);
\par    if (nError != ABFH_SUCCESS)
\par       return FALSE;
\par 
\par    UINT uBufSize = INFO_GetBufferSize( &FH, szFileName, INFO_LONG);\line    char *pszInfoBuf = malloc(uBufSize);
\par    if (!INFO_GetInfo(&FH, szFileName, INFO_LONG, pszInfoBuf, uBufSize))
\par       return FALSE;
\par 
\par    puts(pszInfoBuf);
\par    return TRUE;
\par \}
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1\uldb\cf11 INFO_GetInfo}{\v\f1 INFO_GetInfo}{\f1  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ INFO_GetInfo}}}{ }{\cs16\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ INFO_GetInfo}}}{ }{\cs16\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ INFO_GetInfo}}}{ }{\cs16\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ INFO_GetInfo
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\b\f1 #include "abfinfo.h"}{\f1 
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b\f1 UINT INFO_GetInfo}{\f1 (}{\b\f1 ABFFileHeader}{\f1  }{\i\f1 *pFH}{\f1 , }{\b\f1 char}{\f1  }{\i\f1 *pszFileName}{\f1 ,\line \tab }{\b\f1 int}{\f1  }{\i\f1 nDisplayMode}{\f1 , }{\b\f1 char}{\f1  }{\i\f1 *pszGetInfoBuf}{\f1 , }{\b\f1 UINT}{\f1  }{\i\f1 uBufSize}{\f1 );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {\f1 Fills a text buffer with information found in the passed ABFFileHeader structure.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b\f1 Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pFH}{\f1 \cell Pointer to ABFFileHeader structure to receive  parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pszFileName}{\f1 \cell String containing the name of the file associated with the ABFFileHeader structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 nDisplayMode}{\f1 \cell Flag to specify the type of information required: Valid flags are: INFO_TERSE, INFO_LONG, INFO_VERBOSE.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 pszGetInfoBuf}{\f1 \cell Pointer to text buffer to be filled.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i\f1 uBufSize}{\f1 \cell Size of the buffer pointed to by pszGetInfoBuf\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\f1 \row }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The }{\b\f1 INFO_GetInfo}{\f1  function takes the information in the passed ABFFileHeader and generates a block of text that describes the parameters. The function INFO_GetBufferSize should be called prior to INFO_GetInfo to determine the size of the buffer required by INFO_GetInfo.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1 The number of characters placed into the passed buffer.
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abfheadr.h\rdblquote 
\par }{\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002c000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646554e432e646f63000a0000004444455f4c494e4b36000000000000000000000000000105000000000000}{\result {#include "abfinfo.h"
\par BOOL ShowABFFileInfo(char *szFileName) 
\par \{
\par    ABFFileHeader FH;
\par    int nFile = open(szFileName, O_BINARY, O_READONLY);
\par    if (nFile < 0)
\par       return FALSE;
\par 
\par    int nError = ABFH_ParamReader( nFile, &FH );
\par    close(nFile);
\par    if (nError != ABFH_SUCCESS)
\par       return FALSE;
\par 
\par    UINT uBufSize = INFO_GetBufferSize( &FH, szFileName, INFO_LONG);\line    char *pszInfoBuf = malloc(uBufSize);
\par    if (!INFO_GetInfo(&FH, szFileName, INFO_LONG, pszInfoBuf, uBufSize))
\par       return FALSE;
\par 
\par    puts(pszInfoBuf);
\par    return TRUE;
\par \}
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\f1\uldb\cf11 INFO_GetBufferSize}{\v\f1 INFO_GetBufferSize}{\f1  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFFILES_H}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFFILES.H}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFFILES.H}}}{ }{\cs16\super +{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFFILES.H
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {//**************************************************************************************
\par //
\par //    Copyright (c) 1993-1997 Axon Instruments.
\par //    All rights reserved.
\par //    Permission is granted to freely to use, modify and copy the code in this file.
\par //
\par //**************************************************************************************
\par 
\par #ifndef INC_ABFFILES_H
\par #define INC_ABFFILES_H
\par 
\par #include "..\\axabffio32\\axabffio32.h"
\par 
\par // Include the description of the ABFFileHeader structure
\par #ifndef RC_INVOKED
\par #include "..\\axabffio32\\abfheadr.h"
\par #endif
\par 
\par #ifdef __cplusplus
\par extern "C" \{
\par #endif  /* __cplusplus */
\par 
\par    
\par // This is ABFFILES.H; a companion file to ABFFILES.C
\par 
\par #define ABF_INVALID_HANDLE    -1
\par 
\par // Error numbers for routines in this module. 
\par // Only positive numbers are used.
\par 
\par #define ABF_SUCCESS                 0
\par #define ABF_EUNKNOWNFILETYPE        1001
\par #define ABF_EBADFILEINDEX           1002
\par #define ABF_TOOMANYFILESOPEN        1003
\par #define ABF_EOPENFILE               1004
\par #define ABF_EBADPARAMETERS          1005
\par #define ABF_EREADDATA               1006
\par #define ABF_OUTOFMEMORY             1008
\par #define ABF_EREADSYNCH              1009
\par #define ABF_EBADSYNCH               1010
\par #define ABF_EEPISODERANGE           1011
\par #define ABF_EINVALIDCHANNEL         1012
\par #define ABF_EEPISODESIZE            1013
\par #define ABF_EREADONLYFILE           1014
\par #define ABF_EDISKFULL               1015
\par #define ABF_ENOTAGS                 1016
\par #define ABF_EREADTAG                1017
\par #define ABF_ENOSYNCHPRESENT         1018
\par #define ABF_EREADDACEPISODE         1019
\par #define ABF_ENOWAVEFORM             1020
\par #define ABF_EBADWAVEFORM            1021
\par #define ABF_BADMATHCHANNEL          1022
\par #define ABF_BADTEMPFILE             1023
\par #define ABF_NODOSFILEHANDLES        1025
\par #define ABF_ENOSCOPESPRESENT        1026
\par #define ABF_EREADSCOPECONFIG        1027
\par #define ABF_EBADCRC                 1028
\par #define ABF_ENOCOMPRESSION          1029
\par #define ABF_EREADDELTA              1030
\par #define ABF_ENODELTAS               1031
\par #define ABF_EBADDELTAID             1032
\par #define ABF_EWRITEONLYFILE          1033
\par #define ABF_ENOSTATISTICSCONFIG     1034
\par #define ABF_EREADSTATISTICSCONFIG   1035
\par 
\par // Notifications that can be passed to the registered callback function.
\par #define ABF_NVOICETAGSTART    2000
\par #define ABF_NWRITEVOICETAG    2001
\par #define ABF_NVOICETAGEND      2002
\par 
\par // Constants for the ABF_ReadOpen and ABF_WriteOpen functions
\par #define ABF_DATAFILE          0     
\par #define ABF_PARAMFILE         1     
\par #define ABF_ALLOWOVERLAP      2     // If this flag is not set, overlapping data in fixed-length 
\par                                     // event-detected data will be edited out by adjustment of
\par                                     // the synch array. (ABF_ReadOpen only!)
\par 
\par // Constants for ABF_MultiplexWrite
\par #define ABF_APPEND            2     // Episodes may be appended to the current
\par                                     // episode when writing ABF_VARLNEEVENTS files
\par 
\par // Constant for ABF_FormatTag
\par #define ABF_MAXTAGFORMATLEN   84
\par 
\par // Start time saved in the synch array for the oscilloscope mode average sweep
\par #define ABF_AVERAGESWEEPSTART DWORD(-1)
\par 
\par //---------------------- Exported Function Definitions -------------------------
\par 
\par // Definitions of the procedures provided by Module ABFFILES.BAS
\par 
\par BOOL ABF_Initialize(HINSTANCE hDLL);
\par void ABF_Cleanup(void);
\par 
\par BOOL WINAPI ABF_ReadOpen( LPCSTR szFileName, int *phFile, UINT fFlags, ABFFileHeader *pFH, 
\par                           UINT *puMaxSamples, DWORD *pdwMaxEpi, int *pnError );
\par 
\par BOOL WINAPI ABF_WriteOpen( LPCSTR szFileName, int *phFile, UINT fFlags, ABFFileHeader *pFH, int *pnError );
\par 
\par BOOL WINAPI ABF_UpdateHeader(int nFile, ABFFileHeader *pFH, int *pnError);
\par 
\par BOOL WINAPI ABF_IsABFFile(const char *szFileName, int *pnDataFormat, int *pnError);
\par 
\par BOOL WINAPI ABF_HasData(int nFile, const ABFFileHeader *pFH);
\par 
\par BOOL WINAPI ABF_Close(int nFile, int *pnError);
\par 
\par BOOL WINAPI ABF_MultiplexRead(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                               void *pvBuffer, UINT *puSizeInSamples, int *pnError);
\par 
\par BOOL WINAPI ABF_MultiplexWrite(int nFile, ABFFileHeader *pFH, UINT uFlags, const void *pvBuffer, 
\par                                DWORD dwEpiStart, UINT uSizeInSamples, int *pnError);
\par 
\par BOOL WINAPI ABF_WriteRawData(int nFile, const void *pvBuffer, DWORD dwSizeInBytes, int *pnError);
\par 
\par BOOL WINAPI ABF_ReadChannel(int nFile, const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                             float *pfBuffer, UINT *puNumSamples, int *pnError);
\par                                    
\par BOOL WINAPI ABF_ReadRawChannel(int nFile, const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                                void *pvBuffer, UINT *puNumSamples, int *pnError);
\par                                    
\par BOOL WINAPI ABF_ReadDACFileEpi(int nFile, const ABFFileHeader *pFH, short *pnDACArray,
\par                                DWORD dwEpisode, int *pnError);
\par 
\par BOOL WINAPI ABF_WriteDACFileEpi(int nFile, ABFFileHeader *pFH, const short *pnDACArray, int *pnError);
\par 
\par BOOL WINAPI ABF_GetWaveform(int nFile, const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                             float *pfBuffer, int *pnError);
\par                             
\par BOOL WINAPI ABF_WriteTag(int nFile, ABFFileHeader *pFH, const ABFTag *pTag, int *pnError);
\par 
\par BOOL WINAPI ABF_ReadTags(int nFile, const ABFFileHeader *pFH, DWORD dwFirstTag, ABFTag *pTagArray, 
\par                          UINT uNumTags, int *pnError);
\par 
\par BOOL WINAPI ABF_FormatTag(int nFile, const ABFFileHeader *pFH, long lTagNumber, 
\par                           char *pszBuffer, UINT uSize, int *pnError);
\par 
\par BOOL WINAPI ABF_EpisodeFromSynchCount(int nFile, const ABFFileHeader *pFH, DWORD *pdwSynchCount, 
\par                                       DWORD *pdwEpisode, int *pnError);
\par 
\par BOOL WINAPI ABF_SynchCountFromEpisode(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                                       DWORD *pdwSynchCount, int *pnError);
\par 
\par BOOL WINAPI ABF_GetEpisodeFileOffset(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                                      DWORD *pdwFileOffset, int *pnError);
\par 
\par BOOL WINAPI ABF_GetMissingSynchCount(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                                      DWORD *pdwMissingSynchCount, int *pnError);
\par 
\par BOOL WINAPI ABF_HasOverlappedData(int nFile, BOOL *pbHasOverlapped, int *pnError);
\par 
\par BOOL WINAPI ABF_GetNumSamples(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                               UINT *puNumSamples, int *pnError);
\par 
\par BOOL WINAPI ABF_GetStartTime(int nFile, const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                              double *pdStartTime, int *pnError);
\par 
\par BOOL WINAPI ABF_GetEpisodeDuration(int nFile, const ABFFileHeader *pFH, DWORD dwEpisode, 
\par                                    double *pdDuration, int *pnError);
\par 
\par BOOL WINAPI ABF_WriteScopeConfig( int nFile, ABFFileHeader *pFH, int nScopes, 
\par                                   const ABFScopeConfig *pCfg, int *pnError);
\par                                         
\par BOOL WINAPI ABF_ReadScopeConfig( int nFile, ABFFileHeader *pFH, ABFScopeConfig *pCfg, 
\par                                  UINT uMaxScopes, int *pnError);
\par 
\par BOOL WINAPI ABF_WriteStatisticsConfig( int nFile, ABFFileHeader *pFH, 
\par                                        const ABFScopeConfig *pCfg, int *pnError);
\par                                         
\par BOOL WINAPI ABF_ReadStatisticsConfig( int nFile, const ABFFileHeader *pFH, ABFScopeConfig *pCfg, int *pnError);
\par 
\par BOOL WINAPI ABF_SaveVoiceTag( int nFile, LPCSTR pszFileName, long lDataOffset,
\par                               ABFVoiceTagInfo *pVTI, int *pnError);
\par                               
\par BOOL WINAPI ABF_GetVoiceTag( int nFile, const ABFFileHeader *pFH, UINT uTag, LPCSTR pszFileName, 
\par                              long lDataOffset, ABFVoiceTagInfo *pVTI, int *pnError);
\par                               
\par BOOL WINAPI ABF_PlayVoiceTag( int nFile, const ABFFileHeader *pFH, UINT uTag, int *pnError);
\par 
\par BOOL WINAPI ABF_WriteDelta(int nFile, ABFFileHeader *pFH, const ABFDelta *pDelta, int *pnError);
\par BOOL WINAPI ABF_ReadDeltas(int nFile, const ABFFileHeader *pFH, DWORD dwFirstDelta, 
\par                            ABFDelta *pDeltaArray, UINT uNumDeltas, int *pnError);
\par BOOL WINAPI ABF_FormatDelta(const ABFFileHeader *pFH, const ABFDelta *pDelta, 
\par                             char *pszText, UINT uTextLen, int *pnError);
\par 
\par BOOL WINAPI ABF_BuildErrorText(int nErrorNum, const char *szFileName, char *sTxtBuf, UINT uMaxLen);
\par 
\par typedef BOOL (CALLBACK *ABFCallback)(void *pvThisPointer, int nError);
\par BOOL WINAPI ABF_SetErrorCallback(int nFile, ABFCallback fnCallback, void *pvThisPointer, int *pnError);
\par 
\par // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
\par                                        
\par void *WINAPI ABF_GetSynchArray(int nFile, int *pnError);
\par 
\par BOOL WINAPI ABF_GetFileHandle(int nFile, HANDLE *phHandle, int *pnError);
\par 
\par BOOL WINAPI ABF_UpdateAfterAcquisition(int nFile, ABFFileHeader *pFH, DWORD dwAcquiredEpisodes,
\par                                        DWORD dwAcquiredSamples, int *pnError);
\par 
\par #ifdef __cplusplus
\par \}
\par #endif
\par 
\par #endif   // INC_ABFFILES_H
\par 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\uldb\cf11 The ABF File I/O Functions}{\v The_ABF_File_I_O_Functions}{ 
{\v0\par\v}}{\uldb\cf11 The ABF File I/O Functions by category}{\v The_ABF_File_I_O_Functions_by_category}{ 
{\v0\par\v}}{\uldb\cf11 ABFHEADR.H}{\v ABFHEADR_H}{ 
{\v0\par\v}}{\uldb\cf11 ABFINFO.H}{\v ABFINFO_H}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs16\super #{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super #}{ ABFINFO_H}}}{ }{\cs16\super ${\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super $}{ ABFINFO.H}}}{ }{\cs16\super K{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super K}{ ABFINFO.H}}}{ }{\cs16\super +{\footnote \pard\plain \s17\sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\cs16\super +}{ ABFFUNC}}}{ ABFINFO.H
\par }\pard\plain \s27\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {//**************************************************************************************
\par //
\par //    Copyright (c) 1993-1997 Axon Instruments.
\par //    All rights reserved.
\par //    Permission is granted to freely to use, modify and copy the code in this file.
\par //
\par //**************************************************************************************
\par // HEADER:  ABFINFO.H
\par // PURPOSE: Contains definitions and prototypes for ABFDUMP.CPP
\par //
\par #ifdef __cplusplus
\par extern "C" \{
\par #endif
\par 
\par #include "abfheadr.h"
\par #include "axabffio32.h"
\par 
\par #define INFO_TERSE   0
\par #define INFO_LONG    1
\par #define INFO_VERBOSE 2
\par 
\par // If this character is placed as the first character of the szDataFile field, the following
\par // text is used as a descriptive text for the header. Otherwise the filename component of the 
\par // path is stripped out and used.
\par #define INFO_TEXTMARKER '#'
\par 
\par UINT WINAPI INFO_GetBufferSize( const ABFFileHeader *pFH, LPCSTR szDataFile, int nDisplayMode);
\par UINT WINAPI INFO_GetInfo( const ABFFileHeader *pFH, LPCSTR szDataFile, int nDisplayMode, 
\par                           char *psBuffer, UINT uBufSize);
\par 
\par #ifdef __cplusplus
\par \}
\par #endif
\par 
\par }\pard\plain \s26\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f9\fs20\cgrid {\uldb\cf11 ABFHEADR.H}{\v ABFHEADR_H}{ 
{\v0\par\v}}{\uldb\cf11 ABFFILES.H}{\v ABFFILES_H}{ 
{\v0\par\v}}}
