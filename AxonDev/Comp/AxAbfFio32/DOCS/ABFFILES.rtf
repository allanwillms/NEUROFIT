{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2 Times New Roman;}{\f1\fswiss\fcharset0\fprq2 Arial;}{\f2\fmodern\fcharset0\fprq1 Courier New;}{\f3\froman\fcharset2\fprq2 Symbol;}{\f4\froman\fcharset0\fprq2 Times;}{\f5\fswiss\fcharset0\fprq2 Helvetica;}{\f6\fmodern\fcharset0\fprq1 Courier;}{\f7\fswiss\fcharset0\fprq2 Geneva;}{\f8\froman\fcharset0\fprq2 Tms Rmn;}{\f9\fswiss\fcharset0\fprq2 Helv;}{\f10\froman\fcharset0\fprq2 MS Serif;}{\f11\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 System;}{\f14\fnil\fcharset2\fprq2 Wingdings;}{\f15\fswiss\fcharset0\fprq2 Tahoma;}{\f16\froman\fcharset0\fprq2 CG Times (WN);}{\f17\fswiss\fcharset0\fprq2 Univers;}{\f18\fmodern\fcharset0\fprq1 LinePrinter;}{\f19\froman\fcharset0\fprq2 CG Times;}{\f20\fnil\fcharset2\fprq2 Marlett;}{\f21\fmodern\fcharset0\fprq1 Lucida Console;}{\f22\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f23\fswiss\fcharset0\fprq2 Haettenschweiler;}{\f24\fswiss\fcharset0\fprq2 Arial Black;}{\f25\froman\fcharset0\fprq2 Garamond;}{\f26\froman\fcharset2\fprq2 Bookshelf Symbol 3;}{\f27\fswiss\fcharset2\fprq2 Bookshelf Symbol 4;}{\f28\fnil\fcharset2\fprq2 Bookshelf Symbol 5;}{\f29\fnil\fcharset2\fprq2 MS Outlook;}{\f30\fscript\fcharset0\fprq2 Comic Sans MS;}{\f31\fswiss\fcharset0\fprq2 Verdana;}{\f32\froman\fcharset2\fprq2 Webdings;}{\f33\fswiss\fcharset0\fprq2 AvantGarde Md BT;}{\f34\fswiss\fcharset0\fprq2 AvantGarde Bk BT;}{\f35\froman\fcharset0\fprq2 Book Antiqua;}{\f36\fnil\fcharset2\fprq2 Monotype Sorts;}{\f37\fswiss\fcharset0\fprq2 Arial Narrow;}{\f38\froman\fcharset0\fprq2 Bookman Old Style;}{\f39\fswiss\fcharset0\fprq2 Century Gothic;}{\f40\fscript\fcharset0\fprq2 Monotype Corsiva;}{\f41\froman\fcharset0\fprq2 Century Schoolbook;}{\f42\fswiss\fcharset0\fprq2 Impact;}{\f43\froman\fcharset238\fprq2 Times New Roman CE;}{\f44\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f46\froman\fcharset161\fprq2 Times New Roman Greek;}{\f47\froman\fcharset162\fprq2 Times New Roman Tur;}{\f48\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f49\fswiss\fcharset238\fprq2 Arial CE;}{\f50\fswiss\fcharset204\fprq2 Arial Cyr;}{\f52\fswiss\fcharset161\fprq2 Arial Greek;}{\f53\fswiss\fcharset162\fprq2 Arial Tur;}{\f54\fswiss\fcharset186\fprq2 Arial Baltic;}{\f55\fmodern\fcharset238\fprq1 Courier New CE;}{\f56\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f58\fmodern\fcharset161\fprq1 Courier New Greek;}{\f59\fmodern\fcharset162\fprq1 Courier New Tur;}{\f60\fmodern\fcharset186\fprq1 Courier New Baltic;}{\f133\fswiss\fcharset238\fprq2 Tahoma CE;}{\f134\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f136\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f137\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f138\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f169\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f170\fmodern\fcharset204\fprq1 Lucida Console Cyr;}{\f172\fmodern\fcharset161\fprq1 Lucida Console Greek;}{\f173\fmodern\fcharset162\fprq1 Lucida Console Tur;}{\f175\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE;}{\f176\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr;}{\f178\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek;}{\f179\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur;}{\f187\fswiss\fcharset238\fprq2 Arial Black CE;}{\f188\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f190\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f191\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f192\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f193\froman\fcharset238\fprq2 Garamond CE;}{\f194\froman\fcharset204\fprq2 Garamond Cyr;}{\f196\froman\fcharset161\fprq2 Garamond Greek;}{\f197\froman\fcharset162\fprq2 Garamond Tur;}{\f198\froman\fcharset186\fprq2 Garamond Baltic;}{\f229\fswiss\fcharset238\fprq2 Verdana CE;}{\f230\fswiss\fcharset204\fprq2 Verdana Cyr;}{\f232\fswiss\fcharset161\fprq2 Verdana Greek;}{\f233\fswiss\fcharset162\fprq2 Verdana Tur;}{\f234\fswiss\fcharset186\fprq2 Verdana Baltic;}{\f241\fswiss\fcharset238\fprq2 AvantGarde Md BT CE;}{\f244\fswiss\fcharset161\fprq2 AvantGarde Md BT Greek;}{\f245\fswiss\fcharset162\fprq2 AvantGarde Md BT Tur;}{\f247\fswiss\fcharset238\fprq2 AvantGarde Bk BT CE;}{\f250\fswiss\fcharset161\fprq2 AvantGarde Bk BT Greek;}{\f251\fswiss\fcharset162\fprq2 AvantGarde Bk BT Tur;}{\f265\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f266\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f268\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f269\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f270\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f271\froman\fcharset238\fprq2 Bookman Old Style CE;}{\f272\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f274\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f275\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f276\froman\fcharset186\fprq2 Bookman Old Style Baltic;}{\f295\fswiss\fcharset238\fprq2 Impact CE;}{\f296\fswiss\fcharset204\fprq2 Impact Cyr;}{\f298\fswiss\fcharset161\fprq2 Impact Greek;}{\f299\fswiss\fcharset162\fprq2 Impact Tur;}{\f300\fswiss\fcharset186\fprq2 Impact Baltic;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \snext0 Normal;}{\s1\sb60\sa120\keepn\nowidctlpar\widctlpar\adjustright \b\f1\fs28\cgrid \sbasedon0 \snext0 heading 1;}{\s2\li360\ri360\sb120\nowidctlpar\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 2;}{\s3\sb240\sa60\keepn\nowidctlpar\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}{\s4\li360\sb120\nowidctlpar\widctlpar\adjustright \f1\ul\cgrid \sbasedon0 \snext0 heading 4;}{\s5\sb240\sa60\nowidctlpar\widctlpar\adjustright \f1\fs22\cgrid \sbasedon0 \snext0 heading 5;}{\s6\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f1\fs22\cgrid \sbasedon0 \snext0 heading 6;}{\s7\sb240\sa60\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon0 \snext0 heading 7;}{\s8\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f1\fs20\cgrid \sbasedon0 \snext0 heading 8;}{\s9\sb240\sa60\nowidctlpar\widctlpar\adjustright \i\f1\fs18\cgrid \sbasedon0 \snext0 heading 9;}{\*\cs10 \additive Default Paragraph Font;}{\s15\li360\ri360\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon0 \snext15 Topic Text;}{\s16\li360\sb120\nowidctlpar\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext15 Topic Heading;}{\s17\li180\sb120\nowidctlpar\widctlpar\adjustright \b\f1\fs28\cgrid \sbasedon0 \snext16 Topic Caption;}{\s18\fi-360\li720\ri360\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon15 \snext18 Topic Text Item;}{\s19\li720\ri720\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon15 \snext19 Topic Text Indent;}{\s20\li720\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon0 \snext20 Normal Indent;}{\*\cs21 \additive \super \sbasedon10 footnote reference;}{\s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid \sbasedon0 \snext0 SubHeading;}{\s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid \sbasedon0 \snext23 Source;}{\s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid \sbasedon0 \snext24 footnote text;}{\s25\sb120\nowidctlpar\widctlpar\adjustright \cbpat9 \f15\fs20\cgrid \sbasedon0 \snext25 Document Map;}}{\*\revtbl {Unknown;}}{\info{\title # $ K + The ABF File I/O Functions by category}{\author Bruce Ikin}{\operator Philip Churchward}{\creatim\yr1998\mo4\dy6\hr15}{\revtim\yr1998\mo4\dy6\hr15}{\version2}{\edmins0}{\nofpages76}{\nofwords10473}{\nofchars59699}{\*\company Axon Research}{\nofcharsws73314}{\vern71}}\paperw11907\paperh16840\margl1134\margr1134\margt1134\margb1134 \widowctrl\ftnbj\aenddoc\noextrasprl\prcolbl\cvmme\sprsspbf\brkfrm\swpbdr\lytprtmet\hyphcaps0\fracwidth\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0{\*\template C:\\MSOFFICE\\WINWORD\\ROBORTF.DOT}\sectd \psz9\linex0\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ The_ABF_File_I_O_Functions_by_category}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ The ABF File I/O Functions by category}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ The ABF File I/O Functions by category}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ The ABF File I/O Functions by category
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 Initialization/Cleanup}{\b\v Initialization_Cleanup}{\b  
{\v0\par\v}}{\b\uldb\cf11 File Open/Close}{\b\v File_Open_Close}{\b  
{\v0\par\v}}{\b\uldb\cf11 High Level File Reading}{\b\v High_Level_File_Reading}{\b  
{\v0\par\v}}{\b\uldb\cf11 Low Level File Read/Write}{\b\v Low_Level_File_Read_Write}{\b  
{\v0\par\v}}{\b\uldb\cf11 Miscellaneous Functions}{\b\v Miscellaneous_Functions}{\b  
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Notes:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 Verification of ABF Function Usage}{\b\v Verification_of_ABF_Function_Usage}{\b  \line }{\b\uldb\cf11 Altering Existing Raw Data Files}{\b\v Altering_Existing_Raw_Data_Files}{\b  }{\b\uldb\cf11 \line Compilers}{\b\v Compilers}{\b  \line }{\b\uldb\cf11 Error Return Values}{\b\v Error_Return_Values}{\b  
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 The ABF File I/O Functions}{\b\v The_ABF_File_I_O_Functions}{\b  \line }{\b\uldb\cf11  The ABF File Information Functions by category}{\b\v The_ABF_File_Information_Functions_by_category}{\b  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Notes}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Notes - ABF File I/O Functions}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Notes;Notes - ABF File I/O Functions}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Notes - ABF File I/O Functions
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 Verification of ABF Function Usage}{\b\v Verification_of_ABF_Function_Usage}{\b  \line }{\b\uldb\cf11 Altering Existing Raw Data Files}{\b\v Altering_Existing_Raw_Data_Files}{\b  }{\b\uldb\cf11 \line Compilers}{\b\v Compilers}{\b  \line }{\b\uldb\cf11 Error Return Values}{\b\v Error_Return_Values}{\b  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Initialization_Cleanup}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Initialization/Cleanup}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Initialization/Cleanup}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Initialization/Cleanup
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The initialization and cleanup functions are only necessary when the ABF functions ARE NOT bound into a Windows DLL. In the Windows DLL version the initialize and cleanup functions are called automatically when the DLL is loaded/unloaded. 
\par Windows programs that bind the ABFFILES.CPP module in directly must call ABF_Initialize() before calling any other ABF function. Similarly, ABF_Cleanup() should be called when the ABF functions are no longer required (prior to program termination). 
\par }\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Initialize}{\b\v ABF_Initialize}{\b  \cell }{Initializes the ABFFILES module.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Cleanup}{\b\v ABF_Cleanup}{\b \cell }{Cleans up after use of ABF routines.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ File_Open_Close}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ File Open/Close}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ File Open/Close}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ File Open/Close
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The ABF API functions provides two functions for opening files, one for opening files for reading, the other for opening files for writing. Files opened for writing may not be read from, and files opened for reading may no be written to. The ABF_Close function must always be called to close a file successfully opened with either ABF_ReadOpen or ABF_WriteOpen. 
\par }\trowd \clvertalt\cltxlrtb \cellx3150\clvertalt\cltxlrtb \cellx9720\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx3150\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadOpen}{\b\v ABF_ReadOpen}{\b \cell }{Opens an ABF file for reading.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteOpen}{\b\v ABF_WriteOpen}{\b \cell }{Opens an ABF file for writing.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_UpdateHeader}{\b\v ABF_UpdateHeader}{\b\uldb\cf11  \cell }{Updates the file header and writes the synch array out to disk if required.This routine should always be called before closing a file opened with ABF_WriteOpen. \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3150\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Close}{\b\v ABF_Close}{\b \cell }{Closes an ABF file that was previously opened with either ABF_ReadOpen or ABF_WriteOpen.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ High_Level_File_Reading}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ High Level File Reading}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ High Level File Reading}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ High Level File Reading
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The high level file reading routines return data from the ABF file in fully scaled 4-byte floats, in the units specified by the user (}{\ul\cf11 UserUnits}{\v User_Units}{) at the preparation. 
{\v0\par\v}}\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadChannel}{\b\v ABF_ReadChannel}{\b \cell }{Reads a sweep/chunk of data from a particular }{\ul\cf11 ADC}{\v ADC_A_D}{ channel, returning the data as fully scaled UserUnits.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3159\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetWaveform}{\b\v ABF_GetWaveform}{\b \cell }{Gets the Waveform that was put out for a particular }{\ul\cf11 sweep}{\v Sweep}{ on a particular DAC channel in UserUnits.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Low_Level_File_Read_Write}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Low Level File Read/Write}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Low Level File Read/Write}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Low Level File Read/Write
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The low level file I/O routines read and write raw data in two byte }{\ul\cf11 ADC}{\v ADC_A_D}{/}{\ul\cf11 DAC}{\v DAC_D_A}{ samples. 
{\v0\par\v}}{\b Axon strongly recommends that third party developers use the High Level file reading routines in preference to these low level routines to avoid the complexity of doing the ADC to }{\b\ul\cf11 UserUnits}{\b\v User_Units}{\b  conversion.}{ 
{\v0\par\v}If the low level routines are used, the functions ABFH_GetADCtoUUFactors() and ABFH_GetDACtoUUFactors() should be used to retrieve the composite scale and offset factors used to convert ADC/DAC values to UserUnits. 
{\v0\par\v}}\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_MultiplexRead}{\b\v ABF_MultiplexRead}{\b \cell }{Reads a }{\ul\cf11 sweep}{\v Sweep}{ of multiplexed multi-channel ADC samples from the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_MultiplexWrite}{\b\v ABF_MultiplexWrite}{\b \cell }{Writes a sweep of multiplexed multi-channel ADC samples to the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadDACFileEpi}{\b\v ABF_ReadDACFileEpi}{\b \cell }{Reads a sweep of multiplexed multi-channel DAC samples from the DACFile section of the ABF file (only valid if a DAC file was used for waveform generation).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadRawChannel}{\b\v ABF_ReadRawChannel}{\b  \cell }{Reads a complete multiplexed sweep from the data file and then decimates it, returning single de-multiplexed channel in the raw data format.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadTags}{\b\v ABF_ReadTags}{\b  \cell }{Reads a segment of the tag array from the TAGArray section.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteTag}{\b\v ABF_WriteTag}{\b  \cell }{Writes a tag value to the TAGArray section.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetVoiceTag}{\b\v ABF_ReadTags}{\b \cell }{Retrieves a voice tag from the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SaveVoiceTag}{\b\v ABF_WriteTag}{\b  \cell }{Saves a voice tag to the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_PlayVoiceTag}{\b\v ABF_ReadTags}{\b  \cell }{Retrieves a voice tag, builds a WAV file, plays the WAV file and cleans up.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadDeltas}{\b\v ABF_ReadTags}{\b \cell }{Reads a Delta array from the DeltaArray section of the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteDelta}{\b\v ABF_WriteDelta}{\b  \cell }{Writes the details af a delta to a temporary file.  The deltas are written to the ABF file by ABF_Update.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_FormatDelta}{\b\v ABF_ReadTags}{\b  \cell }{Builds an ASCII string to describe a delta.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadScopeConfig}{\b\v ABF_ReadScopeConfig}{\b  \cell }{Retrieves the scope configuration info from the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteScopeConfig}{\b\v ABF_WriteScopeConfig}{\b  \cell }{Saves the current scope configuration info to the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteStatisticsConfig}{\b\v ABF_WriteScopeConfig}{\b  \cell }{Saves the current statistics window configuration info to the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteDACFileEpi}{\b\v ABF_WriteDACFileEpi}{\b \cell }{Writes a sweep of multiplexed multi-channel DAC samples to the DACFile section of the ABF file. This function should only be used after all acquired data has been written to the file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteRawData}{\b\v ABF_WriteRawData}{\b  \cell }{Writes a raw data buffer to the ABF file at the current file position.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Miscellaneous_Functions}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Miscellaneous Functions}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Miscellaneous Functions}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Miscellaneous Functions
\par }\trowd \clvertalt\cltxlrtb \cellx4140\clvertalt\cltxlrtb \cellx9720\pard\plain \sb240\nowidctlpar\widctlpar\intbl\adjustright \f1\fs20\cgrid {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx4140\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_BuildErrorText}{\b\v ABF_BuildErrorText}{\b \cell }{Build an error string from an error number and a file name.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_EpisodeFromSynchCount}{\b\v ABF_EpisodeFromSynchCount}{\b \cell }{Find the }{\ul\cf11 sweep}{\v Sweep}{ that contains a particular synch count.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_FormatTag}{\b\v ABF_FormatTag}{\b  \cell }{This function reads a tag from the TagArray section and formats it as ASCII text.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetEpisodeDuration}{\b\v ABF_GetEpisodeDuration}{\b  \cell }{Get the duration of a given sweep in ms.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetEpisodeFileOffset}{\b\v ABF_GetEpisodeFileOffset}{\b  \cell }{Returns the sample point offset in the ABF file for the start of the given sweep number that is passed as an argument.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetMissingSynchCount}{\b\v ABF_GetMissingSynchCount}{\b \cell }{Get the count of synch counts missing before the start of this sweep and the end of the previous sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetNumSamples}{\b\v ABF_GetNumSamples}{\b \cell }{Get the number of samples in this sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetStartTime}{\b\v ABF_GetStartTime}{\b  \cell }{Gets the start time in ms for the specified sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_HasData}{\b\v ABF_HasData}{\b  \cell }{Checks whether an open ABF file has any data in it.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_HasOverlappedData}{\b\v ABF_HasOverlappedData}{\b\uldb\cf11  \cell }{Determines if there is any overlapped data in the file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_IsABFFile}{\b\v ABF_IsABFFile}{\b  \cell }{Checks the data format of a given file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SetErrorCallback}{\b\v ABF_SetErrorCallback}{\b  \cell }{This routine sets a callback function to be called in the event of an error occuring.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx4140\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SynchCountFromEpisode}{\b\v ABF_SynchCountFromEpisode}{\b \cell }{Find the synch count at which a particular sweep started.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Use_With_Care}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Use With Care!}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Use With Care!}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Use With Care!
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The following functions are strictly a violation of the design and modularization of the ABF file IO routines, but they are provided for the use of time-critical acquisition programs that require maximum efficiency when doing file I/O during data acquisition.
\par }\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetSynchArray}{\b\v ABF_GetSynchArray}{\b  \cell }{Returns a pointer to the CSynch object used to buffer the Synch array to disk.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetFileHandle}{\b\v ABF_GetFileHandle}{\b  \cell }{Returns the DOS file handle associated with the specified file.  \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx4167\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_UpdateAfterAcquisition}{\b\v ABF_UpdateAfterAcquisition}{\b  \cell }{Update the ABF internal housekeeping after data has been written into a data file without using the ABF file I/O routines.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ The_ABF_File_I_O_Functions}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ The ABF File I/O Functions}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ The ABF File I/O Functions}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ The ABF File I/O Functions
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The ABF file routines are a set of functions for creating and/or accessing ABF data files. Some functions are low level functions that will only be required by users acquiring ABF data files. Other functions provide higher level access to ABF data, returning fully scaled data values in the units of the acquired data.
\par }{\b NOTE:\tab Axon STRONGLY recommends that the ABF header structure should be accessed through the published header files, NOT by byte offsets within the binary image of the file header. In addition the ABFH_nnn functions should be used to extract data from the header where available.
\par }\trowd \clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx9720\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Routine\cell Use\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_BuildErrorText}{\b\v ABF_BuildErrorText}{\b \cell }{Build an error string from an error number and a file name.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Cleanup}{\b\v ABF_Cleanup}{\b \cell }{Cleans up after use of ABF routines.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Close}{\b\v ABF_Close}{\b \cell }{Closes an ABF file that was previously opened with either ABF_ReadOpen or ABF_WriteOpen.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_EpisodeFromSynchCount}{\b\v ABF_EpisodeFromSynchCount}{\b \cell }{Find the sweep that contains a particular synch count.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3510\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_FormatDelta}{\b\v ABF_ReadTags}{\b  \cell }{Builds an ASCII string to describe a delta.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_FormatTag}{\b\v ABF_FormatTag}{\b  \cell }{This function reads a tag from the TagArray section and formats it as ASCII text.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetEpisodeDuration}{\b\v ABF_GetEpisodeDuration}{\b  \cell }{Get the duration of a given sweep in ms.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetEpisodeFileOffset}{\b\v ABF_GetEpisodeFileOffset}{\b  \cell }{Returns the sample point offset in the ABF file for the start of the given sweep number that is passed as an argument.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetFileHandle}{\b\v ABF_GetFileHandle}{\b  \cell }{Returns the DOS file handle associated with the specified file.  \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetMissingSynchCount}{\b\v ABF_GetMissingSynchCount}{\b \cell }{Get the count of synch counts missing before the start of this sweep and the end of the previous sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetNumSamples}{\b\v ABF_GetNumSamples}{\b \cell }{Get the number of samples in this sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3533\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetStartTime}{\b\v ABF_GetStartTime}{\b  \cell }{Gets the start time in ms for the specified sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3510\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetSynchArray}{\b\v ABF_GetSynchArray}{\b  \cell }{Returns a pointer to the CSynch object used to buffer the Synch array to disk.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetWaveform}{\b\v ABF_GetWaveform}{\b \cell }{Gets the Waveform that was put out for a particular sweep on a particular ADC channel in }{\ul\cf11 UserUnits}{\v User_Units}{.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_GetVoiceTag}{\b\v ABF_ReadTags}{\b \cell }{Retrieves a voice tag from the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_HasData}{\b\v ABF_HasData}{\b  \cell }{Checks whether an open ABF file has any data in it.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_HasOverlappedData}{\b\v ABF_HasOverlappedData}{\b\uldb\cf11  \cell }{Determines if there is any overlapped data in the file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_Initialize}{\b\v ABF_Initialize}{\b  \cell }{Initializes the ABFFILES module.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_IsABFFile}{\b\v ABF_IsABFFile}{\b  \cell }{Checks the data format of a given file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_MultiplexRead}{\b\v ABF_MultiplexRead}{\b \cell }{Reads a }{\ul\cf11 sweep}{\v Sweep}{ of multiplexed multi-channel ADC samples from the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_MultiplexWrite}{\b\v ABF_MultiplexWrite}{\b \cell }{Writes a sweep of multiplexed multi-channel ADC samples to the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_PlayVoiceTag}{\b\v ABF_ReadTags}{\b  \cell }{Retrieves a voice tag, builds a WAV file, plays the WAV file and cleans up.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadChannel}{\b\v ABF_ReadChannel}{\b \cell }{Reads a sweep/chunk of data from a particular ADC channel, returning the data as fully scaled UserUnits.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadDACFileEpi}{\b\v ABF_ReadDACFileEpi}{\b \cell }{Reads a sweep of multiplexed multi-channel DAC samples from the DACFile section of the ABF file. (only valid if a DAC file was used for waveform generation)\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadDeltas}{\b\v ABF_ReadTags}{\b \cell }{Reads a Delta array from the DeltaArray section of the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadOpen}{\b\v ABF_ReadOpen}{\b \cell }{Opens an ABF file for reading.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadRawChannel}{\b\v ABF_ReadRawChannel}{\b  \cell }{Reads a complete multiplexed sweep from the data file and then decimates it, returning single de-multiplexed channel in the raw data format.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadScopeConfig}{\b\v ABF_ReadScopeConfig}{\b  \cell }{Retrieves the scope configuration info from the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_ReadTags}{\b\v ABF_ReadTags}{\b  \cell }{Reads a segment of the tag array from the TAGArray section.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SaveVoiceTag}{\b\v ABF_WriteTag}{\b  \cell }{Saves a voice tag to the ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SetErrorCallback}{\b\v ABF_SetErrorCallback}{\b  \cell }{This routine sets a callback function to be called in the event of an error occuring.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_SynchCountFromEpisode}{\b\v ABF_SynchCountFromEpisode}{\b \cell }{Find the synch count at which a particular sweep started.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_UpdateHeader}{\b\v ABF_UpdateHeader}{\b\uldb\cf11  \cell }{Updates the file header and writes the synch array out to disk if required. \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_UpdateAfterAcquisition}{\b\v ABF_UpdateAfterAcquisition}{\b  \cell }{Update the ABF internal housekeeping after data has been written into a data file without using the ABF file I/O routines.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteDACFileEpi}{\b\v ABF_WriteDACFileEpi}{\b \cell }{Writes a sweep of multiplexed multi-channel DAC samples to the DACFile section of the ABF file. This function should only be used after all acquired data has been written to the file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteDelta}{\b\v ABF_WriteDelta}{\b  \cell }{Writes the details af a delta to a temporary file.  The deltas are written to the ABF file by ABF_Update.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteOpen}{\b\v ABF_WriteOpen}{\b \cell }{Opens an ABF file for writing.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteRawData}{\b\v ABF_WriteRawData}{\b  \cell }{Writes a raw data buffer to the ABF file at the current file position.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteScopeConfig}{\b\v ABF_WriteScopeConfig}{\b  \cell }{Saves the current scope configuration info to the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteStatisticsConfig}{\b\v ABF_WriteScopeConfig}{\b  \cell }{Saves the current statistics window configuration info to the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \clvertalt\cltxlrtb \cellx3510\clvertalt\cltxlrtb \cellx9720\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b\uldb\cf11 ABF_WriteTag}{\b\v ABF_WriteTag}{\b  \cell }{Writes a tag value to the TAGArray section.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Notes:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 Error Return Values}{\b\v Error_Return_Values}{\b  
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b\uldb\cf11 The ABF File I/O Functions by category}{\b\v The_ABF_File_I_O_Functions_by_category}{\b  \line }{\b\uldb\cf11  The ABF File Information Functions by category}{\b\v The_ABF_File_Information_Functions_by_category}{\b  
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Error_Return_Values}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Error Return Values}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Error Return Values}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ Error Return Values
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The return type for all ABF API functions is \ldblquote BOOL\rdblquote . The interpretation of this value is that TRUE = Success, and FALSE = Failure of the function. Should a function call fail, an error number indicating the reason for failure is returned in the pnError parameter. If the reason for the error is not required, NULL may be passed for the pnError parameter.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Compilers}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Compilers}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Compilers}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFILES}}}{ Compilers}{\b0 
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The ABF File Support Libraries routines are written in C++.  Compatibility has been tested with the Microsoft Visual C++ V4.x and V5.0 compilers.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\b0 \page }{\cs21\b0\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Verification_of_ABF_Function_Usage}}}{ }{\cs21\b0\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Verification of ABF Function Usage}}}{ }{\cs21\b0\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Verification of ABF Function Usage}}}{ }{\cs21\b0\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFHELP}}}{ Verification of ABF Function Usage
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {To verify data read by either the ABF functions, it is recommended that developers make use of the HEADER.EXE program (provided in both source and executable form).  This will compile under Microsoft Visual C++.  By compiling this program with debugging support you can single step through the reading of data files and see how the ABF routines can be used to retrieve sweeps from data files.  The code in HEADER.CPP for displaying sweeps (procedure ShowEpisode) and copying files (procedure CopyToABF) shows the correct use of the ABF routines.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\b0 \page }{\cs21\b0\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ Altering_Existing_Raw_Data_Files}}}{ }{\cs21\b0\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ Altering Existing Raw Data Files}}}{ }{\cs21\b0\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ Altering Existing Raw Data Files}}}{ }{\cs21\b0\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFHELP}}}{ Altering Existing Raw Data Files
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {Axon Instruments does not easily allow users to change or append data to ABF raw data files, in the belief that raw data is sacrosanct and will often need to be analyzed many times in the future.  We recommend that third-party developers do not allow users to easily delete or modify ABF files.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_BuildErrorText}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_BuildErrorText}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_BuildErrorText}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_BuildErrorText
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_BuildErrorText}{( }{\b int}{ }{\i nError}{, }{\b const char *}{\i szFileName}{,\line \tab }{\b char *}{\i szTxtBuf}{, }{\b UINT}{ }{\i uMaxLen}{ );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {The ABF_BuildErrorText function builds an error message for the specified error number.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1656\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1656\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nError\cell }{Error number to create message from.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i szFileName\cell }{Name of file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i szTxtBuf\cell }{Buffer for error text.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1656\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uMaxLen\cell }{Size of szTxtBuf.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Returns
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {If }{\i nErrorNum}{ contains a valid error number, this function places the generated text into }{\i szTxtBuf}{ and returns TRUE, otherwise it returns FALSE.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The ABF_BuildErrorText function builds an error message based on }{\i nErrorNum}{ and }{\i szFileName}{.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par 
\par BOOL ShowABFError( char *szFileName, int nError )
\par \{
\par    char szTxt[80];
\par    
\par    if (!ABF_BuildErrorText( nError, szFileName, szTxt, sizeof(szTxt) ))
\par       sprintf( szTxt, "Unknown error number: %d\\r\\n", nError );
\par    printf( "ERROR: %s\\n", szTxt );
\par    return FALSE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 Error Return Values}{\v Error_Return_Values}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_Cleanup}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_Cleanup}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_Cleanup}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_Cleanup
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void ABF_Cleanup}{( }{\b void}{ );
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Performs clean-up of the ABF file I/O module after use. 
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The ABF_Cleanup function removes all vestiges of the file I/O module from the system. It should be called once after file I/O processing is completed and no longer required.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par void main( int argc, char **argv )
\par \{
\par    ABFFileHeader FH;
\par    
\par    ABF_Initialize();
\par    ABFH_Initialize(&FH);
\par    Acquisition( argv[1], &FH );
\par    ABF_Cleanup();
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_Initialize}{\v ABF_Initialize}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_Close}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_Close}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_Close}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_Close
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_Close( int}{ }{\i hFile, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Closes the specified data file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_Close}{ function closes the data file specified in }{\i hFile.}{
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX\cell }{Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILE\cell }{Could not close file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par int ReadChannelEpisode( char *pszFileName, int nChannel,
\par                         DWORD dwEpisode, float *pfBuffer, 
\par                         UINT *puNumSamples )
\par \{
\par    int hFile;
\par    int nError;
\par    ABFFileHeader FH;
\par 
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 16 * 1024;
\par    if (!ABF_ReadOpen(pszFileName, &hFile, ABF_DATAFILE, &FH,
\par                      &uMaxSamples, &dwMaxEpi, &nError))
\par       return ShowABFError(pszFileName, nError);
\par    
\par    if (!ABF_ReadChannel( hFile, &FH, nChannel, dwEpisode, pfBuffer,
\par                          puNumSamples, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ \line }{\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_EpisodeFromSynchCount}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_EpisodeFromSynchCount}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_EpisodeFromSynchCount}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_EpisodeFromSynchCount
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_EpisodeFromSynchCount( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{\b , \line \tab DWORD *}{\i pdwSampleNumber}{, }{\b DWORD *}{\i pdwEpisode, \line \tab }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Finds the }{\ul\cf11 sweep}{\v Sweep}{ number that contains a specified synch count.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwSynchCount\cell }{Address of synch count to search for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwEpisode\cell }{Address of sweep number that contains the requested synch count.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_EpisodeFromSynchCount}{ function finds the }{\ul\cf11 sweep}{\v Sweep}{ number for the specifiedsynch count, and stores it in }{\i *pdwEpisode}{.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL FindAnEpisode( char *pszFileName, DWORD *pdwSample, 
\par                     DWORD *pdwEpisode )
\par \{
\par    int hFile;
\par    int nError = 0;
\par    ABFFileHeader FH;
\par    
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 16 * 1024;
\par    
\par    if (!ABF_ReadOpen( pszFileName, &hFile, ABF_DATAFILE,
\par                       &FH, &uMaxSamples, &dwMaxEpi, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    
\par    if (!ABF_EpisodeFromSynchCount( hFile, &FH, pdwSynchCount, pdwEpisode, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_SynchCountFromEpisode}{\v ABF_SynchCountFromEpisode}{ \line }{\uldb\cf11 ABF_GetMissingSynchCount}{\v ABF_GetMissingSynchCount}{ \line }{\uldb\cf11 ABF_GetNumSamples}{\v ABF_GetNumSamples}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_SynchCountFromEpisode}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_SynchCountFromEpisode}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_SynchCountFromEpisode}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_SynchCountFromEpisode
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_SynchCountFromEpisode( int}{ }{\i hFile}{, }{\b const ABFFileHeader}{ *pFH, }{\b DWORD }{\i dwEpisode}{,\line \tab }{\b DWORD *}{\i pdwSynchCount, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Finds the synch count for the start of the specified }{\ul\cf11 sweep}{\v Sweep}{ number.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode\cell }{Sweep number that is being searched for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwSynchCount\cell }{Synch count of the first point in the sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_SynchCountFromEpisode}{ function finds the synch count point number for the start of the specified }{\ul\cf11 sweep}{\v Sweep}{ number. It sets }{\i *pdwSynchCount}{ to the synch count of the first point in the sweep.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE}{\cell Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL CopyDataFile(char *pszFileIn, int nFileIn, ABFFileHeader *pFI, 
\par                   char *pszFileOut, int nFileOut, ABFFileHeader *pFO)
\par \{
\par    UINT uNumSamples = (UINT)pFI->lNumSamplesPerEpisode;
\par    DWORD dwEpiStart, dwMissingSamples;
\par    
\par    short *pnBuffer = (short *)malloc(uNumSamples * sizeof(short));
\par    if (!pnBuffer)
\par    \{
\par       printf("Out of memory!\\n");
\par       return FALSE;
\par    \}
\par    
\par    for (DWORD i=1; i<=(DWORD)pFI->lActualEpisodes; i++)
\par    \{
\par       UINT uFlag = 0;
\par       int nError = 0;
\par       if (!ABF_MultiplexRead( nFileIn, pFI, i, pnBuffer, &uNumSamples,
\par                               &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par    
\par       if (!ABF_SynchCountFromEpisode( nFileIn, pFI, i, &dwEpiStart, 
\par                                  &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par       if (pFI->nOperationMode == ABF_VARLENEVENTS)
\par       \{
\par          if (!ABF_GetMissingSynchCount( nFileIn, pFI, I,
\par                                      &dwMissingSynchCount, &nError ))
\par             return ShowABFError(pszFileIn, nError);
\par          if (dwMissingSynchCount == 0)
\par             uFlag = ABF_APPEND;
\par       \}
\par       if (!ABF_MultiplexWrite( nFileOut, pFO, uFlag, pnBuffer,
\par                                dwEpiStart, uNumSamples, &nError ))
\par          return ShowABFError(pszFileOut, nError);
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_EpisodeFromSynchCount}{\v ABF_EpisodeFromSynchCount}{ \line }{\uldb\cf11 ABF_GetMissingSynchCount}{\v ABF_GetMissingSynchCount}{ \line }{\uldb\cf11 ABF_GetNumSamples}{\v ABF_GetNumSamples}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_FormatTag}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_FormatTag}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_FormatTag}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_FormatTag
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_FormatTag(int }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b long}{ }{\i lTagNumber}{, }{\b char *}{\i pszBuffer}{, \line \tab }{\b UINT}{ }{\i uSize}{, }{\b int *}{\i pnError}{)
\par This function reads a tag from the TagArray section and formats it as ASCII text.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by }{\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i lTagNumber\cell }{Number of the tag entry to format. (The first tag is tag 0)\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pszBuffer}{\cell The buffer to receive the formatted text.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uSize\cell }{The size of the buffer pointed to by pszBuffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {If tag number -1 is requested, the ASCII text returns column headings.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_WriteTag}{\v ABF_WriteTag}{ \line }{\uldb\cf11 ABF_ReadTags}{\v ABF_ReadTags}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetEpisodeDuration}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetEpisodeDuration}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetEpisodeDuration}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetEpisodeDuration
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_GetEpisodeDuration(int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b DWORD}{ }{\i dwEpisode}{, \line \tab }{\b double *}{\i pdDuration}{, }{\b int *}{\i pnError}{)
\par Get the duration of a given }{\ul\cf11 sweep}{\v Sweep}{ in ms.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by }{\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode\cell }{Sweep number to return the start time of. (First sweep is sweep 1).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdDuration}{\cell The location in which to return the start time of the sweep in ms.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetEpisodeFileOffset}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetEpisodeFileOffset}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetEpisodeFileOffset}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetEpisodeFileOffset
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_GetEpisodeFileOffset(int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b DWORD}{ }{\i dwEpisode}{, \line \tab }{\b DWORD *}{\i pdwFileOffset}{, }{\b int *}{\i pnError}{)
\par Returns the }{\ul\cf11 sample}{\v Sample}{ point offset in the ABF file for the start of the given }{\ul\cf11 sweep}{\v Sweep}{ number that is passed as an argument.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by }{\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisodel\cell }{Sweep number to return the start position of. (First sweep is sweep 1).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwFileOffset}{\cell Points to the location in which to return the sample offset of the start of the sweep (in samples per channel).\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetFileHandle}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetFileHandle}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetFileHandle}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetFileHandle
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_GetFileHandle( int}{ }{\i hFile}{, }{\b HANDLE *}{\i phHandle}{, }{\b int *}{\i pnError }{);
\par Returns the DOS file handle associated with the specified file.  This function should not need to be called if all access to ABF files are performed through the ABF file routines. It is provided for debugging purposes and for acquisition programs that do their own file I/O for performance reasons.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i phHandle}{\cell DOS file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_GetFileHandle}{ function sets }{\i *phHandle}{ to the DOS file handle associated with the file specified in }{\i hFile. }{If the file is written to through the handle obtained by this function, then }{\b ABF_UpdateAfterAcquisition}{ must be called prior to }{\b ABF_UpdateHeader}{.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL Acquisition( char *pszFileName, ABFFileHeader *pFH )
\par \{
\par    int hFile;
\par    HANDLE hHandle;
\par    int nError = 0;
\par    DWORD dwEpisodes, dwSamples;
\par    
\par    if (!ABF_WriteOpen( pszFileName, &hFile, ABF_DATAFILE, pFH, 
\par                        &nError ) )
\par       return ShowABFError(pszFileName, nError);
\par    if (!ABF_GetFileHandle( hFile, &hHandle, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    AcquireAndWriteData( hHandle, pFH, &dwEpisodes, &dwSamples );
\par    if (!ABF_UpdateAfterAcquisition( hFile, pFH, dwEpisodes, dwSamples,
\par                                     &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_UpdateHeader( hFile, pFH, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_UpdateAfterAcquisition}{\v ABF_UpdateAfterAcquisition}{ \line }{\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ \line }{\uldb\cf11 ABF_UpdateHeader}{\v ABF_UpdateHeader}{ \line }{\uldb\cf11 ABF_Close}{\v ABF_Close}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_HasOverlappedData}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_HasOverlappedData}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_HasOverlappedData}}}{ ABF_HasOverlappedData 
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include \ldblquote Abffiles.h\rdblquote 
\par BOOL WINAPI ABF_HasOverlappedData(int}{ nFile, }{\b BOOL }{*pbHasOverlapped, }{\b int}{ *pnError}{\b )}{
\par Returns true if the file contains overlapped data.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {pbHasOverlapped\cell True if file contains overlapped data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_HasOverlappedData}{ determines if there is any overlapped data in the file.  This can only occur in Fixed-length events detected mode when one sweep finishes after the following one starts.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The following error code may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_ EWRITEONLYFILE}{\cell The file is write only.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL OpenABFFile( char *pszFileName, BOOL *pbOverlappedData )
\par \{
\par    int hFile;
\par    int nError = 0;
\par    ABFFileHeader FH;
\par    
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 16 * 1024;
\par    
\par    if (!ABF_ReadOpen( pszFileName, &hFile, ABF_DATAFILE,
\par                       &FH, &uMaxSamples, &dwMaxEpi, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    if( !ABFHasOverlappedData( &hFile, pbOverlappedData, &nError )
\par       return ShowABFError( pszFileName, nError );  
\par return TRUE;
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteStatisticsConfig}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteStatisticsConfig}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteStatisticsConfig}}}{ ABF_WriteStatisticsConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par }{\b BOOL ABF_WriteStatisticsConfig( int}{ nFile, }{\b ABFFileHeader }{*pFH, 
\par                                        }{\b const ABFScopeConfig}{ *pCfg, }{\b int}{ *pnError}{\b );}{
\par Write the scope config structure for the statistics window out to the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{ABFFileHeader.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pCfg\cell }{ABFScopeConfig.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteStatisticsConfig}{ function writes the ABFScopeConfig structure to the ABF file.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADONLYFILE\cell }{The file is read only.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EDISKFULL\cell }{The disk is full.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par BOOL CopyStatsConfig( ABFFileHeader *pFI, ABFFileHeader *pFO )
\par \{
\par    if (pFI.lStatisticsConfigPtr)
\par    \{
\par       static ABFScopeConfig StatsCfg;
\par       if (!ABF_ReadStatisticsConfig( nFileIn, pFI, &StatsCfg, &nErrorNum))
\par          ErrorReturn( nErrorNum );
\par       if (!ABF_WriteStatisticsConfig( nFileOut, pFO, &StatsCfg, &nErrorNum))
\par         ErrorReturn( nErrorNum );
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadStatisticsConfig}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadStatisticsConfig}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadStatisticsConfig}}}{ ABF_ReadStatisticsConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par }{\b BOOL ABF_WriteStatisticsConfig( int}{ nFile, }{\b ABFFileHeader }{*pFH, 
\par                                        }{\b const ABFScopeConfig}{ *pCfg, }{\b int}{ *pnError}{\b );}{
\par Read the scope configuration structure for the statistics window from the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{ABFFileHeader.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pCfg\cell }{ABFScopeConfig.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteStatisticsConfig}{ function writes the ABFScopeConfig structure to the ABF file.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_ENOSTATISTICSCONFIG\cell }{The file has no statistics window infomation.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADSTATISTICSCONFIG\cell }{There was an error reading the statistics window configuration.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par BOOL CopyStatsConfig( ABFFileHeader *pFI, ABFFileHeader *pFO )
\par \{
\par    if (pFI.lStatisticsConfigPtr)
\par    \{
\par       static ABFScopeConfig StatsCfg;
\par       if (!ABF_ReadStatisticsConfig( nFileIn, pFI, &StatsCfg, &nErrorNum))
\par          ErrorReturn( nErrorNum );
\par       if (!ABF_WriteStatisticsConfig( nFileOut, pFO, &StatsCfg, &nErrorNum))
\par         ErrorReturn( nErrorNum );
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_SaveVoiceTag}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_SaveVoiceTag}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_SaveVoiceTag}}}{ ABF_SaveVoiceTag
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_SaveVoiceTag( int}{ nFile, }{\b LPCSTR}{ pszFileName, }{\b long}{ lDataOffset,
\par                               }{\b ABFVoiceTagInfo}{ *pVTI, }{\b int}{ *pnError);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Saves a voice tag to the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pszFileName}{\cell File containing voice tag.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {lDataOffset\cell Position of voice tag in file .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pVTI\cell }{Voice Tag Info struct\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_SaveVoiceTag}{ function saves a voice tag from a temporary file to the ABF file.
\par }{\b Possible Error Codes
\par }{One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_OUTOFMEMORY\cell }{Could not allocate internal buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par BOOL SaveVoiceTag( int nFile, ABFFileHeader *pFH, ABFTag *pTag )
\par \{
\par    char szWAVFile[_MAX_PATH];
\par    if( !ABFU_GetTempFileName("wav", 0, szWAVFile) )
\par       return FALSE;
\par 
\par    // Extract the voice tag to the temp file.
\par    ABFVoiceTagInfo VTI;
\par 
\par    BOOL bReturn ABF_GetVoiceTag( nFile, pFH,
\par                          pTag->nVoiceTagNumber, szWAVFile, 0, &VTI, NULL );
\par    if( !bReturn)
\par    \{
\par       DeleteFile( szWAVFile );
\par       return FALSE;
\par    \}
\par 
\par    // and save it to the pending list
\par    bReturn = ABF_SaveVoiceTag( m_hABFHandle, szWAVFile, 0, &VTI, NULL);
\par    if( !bReturn)
\par       DeleteFile( szWAVFile );
\par    
\par    return bReturn;
\par \}
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetVoiceTag}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetVoiceTag}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetVoiceTag}}}{ ABF_GetVoiceTag
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_GetVoiceTag( int}{ nFile, }{\b const ABFFileHeader}{ *pFH, }{\b UINT}{ uTag, }{\b LPCSTR}{ pszFileName, 
\par                              }{\b long}{ lDataOffset, }{\b ABFVoiceTagInfo}{ *pVTI, }{\b int}{ *pnError) 
\par Retrieves a voice tag from the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell ABF file header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {uTag\cell Tag number.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {pszFileName\cell File name of file to extract voice tag to.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {lDataOffset\cell Position of voice tag in file .\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pVTI\cell }{Voice Tag Info struct\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_GetVoiceTag}{ function retrieves a voice tag from the ABF file.
\par }{\b Possible Error Codes
\par }{One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADDATA\cell }{Error reading data from file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADTAG\cell }{Error reading tag from file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par BOOL SaveVoiceTag( int nFile, ABFFileHeader *pFH, ABFTag *pTag )
\par \{
\par    char szWAVFile[_MAX_PATH];
\par    if( !ABFU_GetTempFileName("wav", 0, szWAVFile) )
\par       return FALSE;
\par 
\par    // Extract the voice tag to the temp file.
\par    ABFVoiceTagInfo VTI;
\par 
\par    BOOL bReturn ABF_GetVoiceTag( nFile, pFH,
\par                          pTag->nVoiceTagNumber, szWAVFile, 0, &VTI, NULL );
\par    if( !bReturn)
\par    \{
\par       DeleteFile( szWAVFile );
\par       return FALSE;
\par    \}
\par 
\par    // and save it to the pending list
\par    bReturn = ABF_SaveVoiceTag( m_hABFHandle, szWAVFile, 0, &VTI, NULL);
\par    if( !bReturn)
\par       DeleteFile( szWAVFile );
\par    
\par    return bReturn;
\par \}
\par }\pard\plain \s1\sb60\sa120\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_PlayVoiceTag}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_PlayVoiceTag}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_PlayVoiceTag}}}{ ABF_PlayVoiceTag
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_PlayVoiceTag( int }{nFile,}{\b  const ABFFileHeader }{*pFH,}{\b  UINT }{uTag,}{\b  int }{*pnError}{\b )
\par }{Retrieves a voice tag, builds a WAV file, plays the WAV file and cleans up.
\par Retrieves a voice tag from the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell ABF file header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {uTag\cell Tag number.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_PlayVoiceTag}{ function retrieves a voice tag from the ABF file, builds a WAV file, plays the WAV file and cleans up.
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {.
\par }{\b Possible Error Codes
\par }{One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_BADTEMPFILE\cell }{Error creating WAV file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include \ldblquote abffiles.h\rdblquote 
\par void ProcessVoiceTags(char *pszDataFile, ABFFileHeader *pFH)
\par \{
\par    int   nFile;
\par    int   nErrorNum   = 0;
\par    UINT  uMaxSamples = 0;
\par    DWORD dwMaxEpi    = 0;
\par    
\par    if (!ABF_ReadOpen(pszDataFile, &nFile, ABF_DATAFILE, pFH, 
\par }\pard \s23\fi720\li1440\nowidctlpar\widctlpar\adjustright { &uMaxSamples, &dwMaxEpi, &nErrorNum))
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {   \{
\par       ShowABFError(nErrorNum, pszDataFile);
\par       return;
\par    \}
\par    
\par    if ((pFH->lVoiceTagPtr == 0) || (pFH->lVoiceTagEntries == 0))
\par    \{
\par       ABF_Close(nFile, NULL);
\par       Pause_printf( "Data file does not contain any voice tags.\\n");
\par       return;
\par    \}
\par 
\par    for (UINT i=0; i< UINT(pFH->lVoiceTagEntries); i++)
\par      if (!ABF_PlayVoiceTag( nFile, pFH, i, &nErrorNum))
\par             break;
\par 
\par    ABF_Close(nFile, NULL);
\par 
\par    if (nErrorNum)
\par       ShowABFError(nErrorNum, g_szDataFile);
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteDelta}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteDelta}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteDelta}}}{ ABF_WriteDelta
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_WriteDelta(int}{ nFile, }{\b ABFFileHeader}{ *pFH, }{\b const ABFDelta}{ *pDelta, }{\b int}{ *pnError)
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Writes a delta (a parameter which is changed during a recording) to a temporary file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell ABF File Header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pDelta}{\cell ABFDelta structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteDelta}{ function writes the details af a parameter which is changed during a recording, to a temporary file.  The deltas are written to the ABF file by ABF_Update.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADONLYFILE\cell }{The file is read only.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\cell \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_FormatDelta}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_FormatDelta}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_FormatDelta}}}{ ABF_FormatDelta
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_FormatDelta(const ABFFileHeader }{*pFH, }{\b const ABFDelta}{ *pDelta, }{\b char}{ *pszText, 
\par }\pard \li2160\sb120\nowidctlpar\widctlpar\adjustright {    }{\b UINT}{ uTextLen, }{\b int}{ *pnError)
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {This function builds an ASCII string to describe a delta.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell ABF File Header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pDelta}{\cell ABFDelta structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pszText\cell }{The text buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uTextLen\cell }{Length of the text buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_FormatDelta}{ function builds an ASCII string (pszText) to describe a delta (pDelta).
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_EBADDELTAID}{\b \cell }{The Delta has an unknown parameter ID.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\cell \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {static void ShowDeltas(char *pszDataFile, ABFFileHeader *pFH)
\par \{
\par    int    nFile;
\par    int    nErrorNum   = 0;
\par    UINT   uMaxSamples = 0;
\par    DWORD  dwMaxEpi    = 0;
\par    
\par    if (!ABF_ReadOpen(pszDataFile, &nFile, ABF_DATAFILE, pFH, &uMaxSamples, 
\par }\pard \s23\fi720\li1440\nowidctlpar\widctlpar\adjustright { &dwMaxEpi, &nErrorNum))
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {   \{
\par       ShowABFError(nErrorNum, g_szDataFile);
\par       return;
\par    \}
\par    
\par    if ((pFH->lDeltaArrayPtr <= 4) || (pFH->lNumDeltas < 1))
\par    \{
\par       ABF_Close(nFile, NULL);
\par       Pause_printf( "Data file does not contain any deltas.\\n");
\par       return;
\par    \}
\par    
\par    ABFDelta Delta;
\par    char szText[80];
\par 
\par    for (DWORD i=0; i<(DWORD)pFH->lNumDeltas; i++)
\par    \{
\par       if (!ABF_ReadDeltas(nFile, pFH, i, &Delta, 1, &nErrorNum))
\par       \{
\par          ABF_Close(nFile, NULL);
\par          ShowABFError(nErrorNum, g_szDataFile);
\par          return;
\par       \}
\par       Pause_printf( "%7lu %8ld   ", i+1, Delta.lDeltaTime);
\par }\pard \s23\fi720\nowidctlpar\widctlpar\adjustright {if( ABF_FormatDelta( pFH, &Delta, &szText[0], sizeof(szText), &nErrorNum ) )
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {         Pause_printf( " %s \\n", szText);
\par       else
\par       \{
\par          ABF_Close(nFile, NULL);
\par          ShowABFError(nErrorNum, g_szDataFile);
\par          return;
\par       \}
\par    \}
\par    ABF_Close(nFile, NULL);
\par \}
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadDeltas}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadDeltas}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadDeltas}}}{ ABF_ReadDeltas
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_ReadDeltas(int }{nFile, }{\b const ABFFileHeader}{ *pFH, }{\b DWORD}{ dwFirstDelta, 
\par }\pard \li2160\sb120\nowidctlpar\widctlpar\adjustright {                           }{\b ABFDelta}{ *pDeltaArray, }{\b UINT}{ uNumDeltas, }{\b int}{ *pnError)
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {This function reads a Delta array from the DeltaArray section of the ABF file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell ABF file Header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwFirstDelta\cell }{The first delta to read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pDeltaArray}{\cell ABFDelta structure.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uNumDeltas\cell }{The number of deltas to read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_ReadDeltas}{ function reads a Delta array (pDeltaArray) from the DeltaArray section of the ABF file.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_EREADDELTA\cell Error reading delta from file\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_ENODELTAS\cell File does not contain any delta information.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_EREADTAG}{\b \cell }{Error reading tag from file\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx7371\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\cell \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {static void ShowDeltas(char *pszDataFile, ABFFileHeader *pFH)
\par \{
\par    int    nFile;
\par    int    nErrorNum   = 0;
\par    UINT   uMaxSamples = 0;
\par    DWORD  dwMaxEpi    = 0;
\par    
\par    if (!ABF_ReadOpen(pszDataFile, &nFile, ABF_DATAFILE, pFH, &uMaxSamples, 
\par }\pard \s23\fi720\li1440\nowidctlpar\widctlpar\adjustright { &dwMaxEpi, &nErrorNum))
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {   \{
\par       ShowABFError(nErrorNum, g_szDataFile);
\par       return;
\par    \}
\par    
\par    if ((pFH->lDeltaArrayPtr <= 4) || (pFH->lNumDeltas < 1))
\par    \{
\par       ABF_Close(nFile, NULL);
\par       Pause_printf( "Data file does not contain any deltas.\\n");
\par       return;
\par    \}
\par    
\par    ABFDelta Delta;
\par    char szText[80];
\par 
\par    for (DWORD i=0; i<(DWORD)pFH->lNumDeltas; i++)
\par    \{
\par       if (!ABF_ReadDeltas(nFile, pFH, i, &Delta, 1, &nErrorNum))
\par       \{
\par          ABF_Close(nFile, NULL);
\par          ShowABFError(nErrorNum, g_szDataFile);
\par          return;
\par       \}
\par       Pause_printf( "%7lu %8ld   ", i+1, Delta.lDeltaTime);
\par }\pard \s23\fi720\nowidctlpar\widctlpar\adjustright {if( ABF_FormatDelta( pFH, &Delta, &szText[0], sizeof(szText), &nErrorNum ) )
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {         Pause_printf( " %s \\n", szText);
\par       else
\par       \{
\par          ABF_Close(nFile, NULL);
\par          ShowABFError(nErrorNum, g_szDataFile);
\par          return;
\par       \}
\par    \}
\par    ABF_Close(nFile, NULL);
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetMissingSynchCount}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetMissingSynchCount}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetMissingSynchCount}}}{ ABF_GetMissingSynchCount
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_GetMissingSynchCount( int}{ }{\i hFile}{, }{\b DWORD }{\i dwEpisode}{,\line \tab }{\b DWORD *}{\i pdwMissingSamples, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Returns the number of synch counts missing before the specified }{\ul\cf11 sweep}{\v Sweep}{ (event detected files only).
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode}{\cell Sweep number.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwMissingSamples}{\cell Number of synch count absent prior to this sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_GetMissingSynchCount}{ function finds the number of synch count missing for event detected data for the specified }{\ul\cf11 sweep}{\v Sweep}{, and stores it in }{\i *pdwMissingSynchCount}{.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE}{\cell Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b34000000000000000000000000000105000000000000}{\result {BOOL CopyDataFile(char *pszFileIn, int nFileIn, ABFFileHeader *pFI, 
\par                   char *pszFileOut, int nFileOut, ABFFileHeader *pFO)
\par \{
\par    UINT uNumSamples = (UINT)pFI->lNumSamplesPerEpisode;
\par    DWORD dwEpiStart, dwMissingSamples;
\par    
\par    short *pnBuffer = (short *)malloc(uNumSamples * sizeof(short));
\par    if (!pnBuffer)
\par    \{
\par       printf("Out of memory!\\n");
\par       return FALSE;
\par    \}
\par    
\par    for (DWORD i=1; i<=(DWORD)pFI->lActualEpisodes; i++)
\par    \{
\par       UINT uFlag = 0;
\par       int nError = 0;
\par       if (!ABF_MultiplexRead( nFileIn, pFI, i, pnBuffer, &uNumSamples,
\par                               &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par    
\par       if (!ABF_SynchCountFromEpisode( nFileIn, pFI, i, &dwEpiStart, 
\par                                  &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par       if (pFI->nOperationMode == ABF_VARLENEVENTS)
\par       \{
\par          if (!ABF_GetMissingSynchCount( nFileIn, pFI, I,
\par                                      &dwMissingSynchCount, &nError ))
\par             return ShowABFError(pszFileIn, nError);
\par          if (dwMissingSynchCount == 0)
\par             uFlag = ABF_APPEND;
\par       \}
\par       if (!ABF_MultiplexWrite( nFileOut, pFO, uFlag, pnBuffer,
\par                                dwEpiStart, uNumSamples, &nError ))
\par          return ShowABFError(pszFileOut, nError);
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_GetNumSamples}{\v ABF_GetNumSamples}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetNumSamples}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetNumSamples}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetNumSamples}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetNumSamples
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_GetNumSamples( int}{ }{\i hFile}{, }{\b DWORD }{\i dwEpisode}{,\line \tab }{\b UINT *}{\i puNumSamples, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Finds the number of }{\v sampleSamples }{in the specified }{\ul\cf11 sweep}{\v Sweep}{.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode}{\cell Interesting sweep number.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i puNumSamples}{\cell Number of data points in this sweep.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_GetNumSamples}{ function finds the number of samples in the specified }{\ul\cf11 sweep}{\v Sweep}{, and returns it in }{\i *puNumSamples}{.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE}{\cell Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL HowManySamples( char *pszFileName, DWORD dwSweep)
\par \{
\par    int hFile;
\par    int nError;
\par    ABFFileHeader FH;
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 0;
\par    UINT uNumSamples;
\par    uMaxSamples = 16 * 1024;
\par    if (!ABF_ReadOpen( pszFileName, &hFile, ABF_DATAFILE, &FH,
\par                       &uMaxSamples, &dwMaxEpi, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    if (!ABF_GetNumSamples( hFile, &FH, dwSweep, &uNumSamples, 
\par                            &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    ABF_Close( hFile, NULL );
\par    printf( "The number of samples is %u\\n", uNumSamples );
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\v\uldb\cf11 ABF_GetMissingSynchCount}{\v ABF_GetMissingSynchCount}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetStartTime}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetStartTime}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetStartTime}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetStartTime
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_GetStartTime(int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b int}{ }{\i nChannel}{, \line \tab }{\b DWORD }{\i dwSweep}{, }{\b float *}{\i pfStartTime}{, }{\b int *}{\i pnError}{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Gets the start time in ms for the specified sweep.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by ABF_ReadOpen.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nChannel\cell }{\ul\cf11 ADC}{\v ADC_A_D}{ channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode}{\cell Sweep number to return the start time for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pfStartTime}{\cell Location in which to return the start time in ms.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_GetStartTime}{ function returns the time at which the sweep of interest in the channel specified started.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE}{\cell Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL GetStartEndTime( int nChannel, DWORD dwEpisode, float *pfTimeBase,
\par }\pard \s23\li2160\nowidctlpar\widctlpar\adjustright {  float *pfStartTime, float *pfEndTime, 
\par   int *pnError )
\par }\pard \s23\nowidctlpar\widctlpar\adjustright {\{
\par if ( ABF_GetStartTime( GetFileHandle(), &GetFileHeader(),
\par                        nChannel, dwEpisode,
\par                        &fStartTime, pnError ) == FALSE )
\par    return FALSE;
\par 
\par UINT uSamples = GetNumberSamples( GetMaximumEpisodes() - 1, NULL );
\par // Compensate for the length of the last trace
\par fStartTime += pfTimeBase;
\par // Add another trace to put space between us and the last trace
\par fStartTime += pfTimeBase;
\par 
\par if( pfStartTime != NULL )
\par   *pfStartTime = fStartTime;
\par if( pfEndTime != NULL )
\par \{
\par    UINT uSamples = GetNumberSamples(dwEpisode, NULL);
\par       *pfEndTime = fStartTime + pfTimeBase;
\par \}
\par    
\par return TRUE;
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetSynchArray}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetSynchArray}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetSynchArray}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetSynchArray
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b void *ABF_GetSynchArray(int }{\i nFile}{, }{\b int *}{\i pnError}{)
\par Returns a pointer to the CSynch object used to buffer the Synch array to disk. Use with care!!
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_GetWaveform}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_GetWaveform}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_GetWaveform}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_GetWaveform
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_GetWaveform(int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b int}{ }{\i nChannel}{, \line \tab }{\b DWORD }{\i dwEpisode}{, }{\b float *}{\i pfBuffer}{, }{\b int *}{\i pnError}{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Gets the }{\ul\cf11 DAC}{\v DAC_D_A}{ output waveform for the specified }{\ul\cf11 sweep}{\v Sweep}{.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by ABF_ReadOpen.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nChannel\cell }{\ul\cf11 DAC}{\v ADC_A_D}{ channel of interest.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode}{\cell Sweep number to return the start time for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pfBuffer}{\cell Address of buffer to fill with DAC output waveform.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\adjustright {Comments
\par The }{\b ABF_GetWaveform}{ function returns the DAC output waveform for a particular }{\ul\cf11 sweep}{\v Sweep}{, in DAC }{\ul\cf11 UserUnits}{\v User_Units}{.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE}{\cell Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2649\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par BOOL ShowWaveforms(char *pszFileName, int nFile, 
\par                    ABFFileHeader *pFH, int nChannel)
\par \{
\par    int nError;
\par    DWORD I;
\par    UINT uNumSamples = (UINT)pFH->lNumSamplesPerEpisode / 
\par                       pFH->nADCNumChannels;
\par    float *pfBuffer = (float *)malloc(uNumSamples *
\par                                      sizeof(float));
\par    if (!pfBuffer)
\par    \{
\par       printf("Out of memory!\\n");
\par       return FALSE;
\par    \}
\par    for (DWORD i=1; i<=(DWORD)pFH->lActualEpisodes; I++)
\par    \{
\par       if (!ABF_GetWaveform(nFile, pFH, nChannel, i, pfBuffer,
\par                            &nError))
\par       \{
\par          free(pfBuffer);
\par          return ShowABFError(pszFileName, nError);
\par       \}
\par       printf("Episode %lu\\n", i);
\par       for (UINT j=0; j<uNumSamples; j++)
\par          printf("%g\\n", pfBuffer[j]);
\par    \}
\par    free(pfBuffer);
\par    return TRUE;
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_HasData}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_HasData}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_HasData}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_HasData
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void ABF_HasData( int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{\b  );}{
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Checks whether an open ABF file has any data in it.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file as returned by }{\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ or }{\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_HasData}{ function will examine an open ABF file and return TRUE if there is any data in the file, and FALSE if there is not.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_IsABFFile}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_IsABFFile}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_IsABFFile}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_IsABFFile
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void ABF_IsABFFile( const char *}{\i pszFileName}{\b , int *}{\i pnDataFormat}{\b , int *}{\i pnError}{\b  );}{
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Checks the data format of a given file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pszFileName}{\cell Path name of the file to be tested.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnDataFormat\cell }{Location to return the value of nDataFormat if it is an ABF file. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError}{\b  }{\i \cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_IsABFFile}{ function is used to determine firstly whether a file is an ABF file, and then if it is an ABF file, what type of ABF file it is. The value returned in the location pointed to by }{\i pnDataFormat}{ will be the same value in the nDataFormat field in the header of the file if it is an ABF file.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_Initialize}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_Initialize}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_Initialize}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_Initialize
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b void ABF_Initialize( void );}{
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Initializes the ABF file I/O module.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_Initialize}{ function is used to perform initialization of the file I/O module. This function must be called prior to the use of any other functions in the I/O module. In the Windows DLL version this function is called automatically when the DLL is loaded, and hence is not exported by the DLL.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b31000000000000000000000000000105000000000000}{\result {void main( int argc, char **argv )
\par \{
\par    ABFFileHeader FH;
\par    
\par    ABF_Initialize();
\par    ABFH_Initialize(&FH);
\par    Acquisition( argv[1], &FH );
\par    ABF_Cleanup();
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_Cleanup}{\v ABF_Cleanup}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_MultiplexRead}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_MultiplexRead}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_MultiplexRead}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_MultiplexRead
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_MultiplexRead( int}{ }{\i hFile}{, }{\b ABFFileHeader}{\i  pFH}{\b , \line \tab DWORD}{ }{\i dwEpisode}{, }{\b void *}{\i pvBuffer}{, }{\b UINT *}{\i puNumSamples,\line \tab  }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Reads a }{\ul\cf11 sweep}{\v Sweep}{ of data from a previously opened data file. The data is returned with all channels multiplexed together.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file being read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode\cell }{Sweep number to be read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pvBuffer}{\cell Data buffer for the data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i puNumSamples}{\cell Number of valid points returned in the data buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_MultiplexRead}{ function reads }{\ul\cf11 sweep}{\v Sweep}{ number }{\i dwEpisode}{ from }{\i hFile}{ into }{\i pvBuffer}{. The actual number of points read into the buffer is returned in }{\i *puNumSamples}{. Only in the case of ABF_VARLENEVENTS mode or at the end of an ABF_GAPFREEFILE file will }{\i *puNumSamples}{ differ from the value returned by ABF_ReadOpen in }{\i *puMaxSamples}{.
{\v0\par\v}It is up to the user of this routine to ensure that the buffer passed in as pvBuffer points to an array of at least pFH->lNumSamplesPerEpisode samples in length. Where the file header pFH was returned by the ABF_ReadOpen command.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2790\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2790\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE\cell }{Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADDATA\cell }{Could not read sweep data from file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2790\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX\cell }{Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b34000000000000000000000000000105000000000000}{\result {BOOL CopyDataFile(char *pszFileIn, int nFileIn, ABFFileHeader *pFI, 
\par                   char *pszFileOut, int nFileOut, ABFFileHeader *pFO)
\par \{
\par    UINT uNumSamples = (UINT)pFI->lNumSamplesPerEpisode;
\par    DWORD dwEpiStart, dwMissingSamples;
\par    
\par    short *pnBuffer = (short *)malloc(uNumSamples * sizeof(short));
\par    if (!pnBuffer)
\par    \{
\par       printf("Out of memory!\\n");
\par       return FALSE;
\par    \}
\par    
\par    for (DWORD i=1; i<=(DWORD)pFI->lActualEpisodes; i++)
\par    \{
\par       UINT uFlag = 0;
\par       int nError = 0;
\par       if (!ABF_MultiplexRead( nFileIn, pFI, i, pnBuffer, &uNumSamples,
\par                               &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par    
\par       if (!ABF_SynchCountFromEpisode( nFileIn, pFI, i, &dwEpiStart, 
\par                                  &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par       if (pFI->nOperationMode == ABF_VARLENEVENTS)
\par       \{
\par          if (!ABF_GetMissingSynchCount( nFileIn, pFI, I,
\par                                      &dwMissingSynchCount, &nError ))
\par             return ShowABFError(pszFileIn, nError);
\par          if (dwMissingSynchCount == 0)
\par             uFlag = ABF_APPEND;
\par       \}
\par       if (!ABF_MultiplexWrite( nFileOut, pFO, uFlag, pnBuffer,
\par                                dwEpiStart, uNumSamples, &nError ))
\par          return ShowABFError(pszFileOut, nError);
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_MultiplexWrite}{\v ABF_MultiplexWrite}{ \line }{\uldb\cf11 ABF_ReadChannel}{\v ABF_ReadChannel}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_MultiplexWrite}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_MultiplexWrite}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_MultiplexWrite}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_MultiplexWrite
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_MultiplexWrite( int}{ }{\i hFile}{, }{\b ABFFileHeader *pFH, \line \tab UINT}{ u}{\i Flags}{, }{\b void *}{\i pvBuffer}{, }{\b DWORD}{ }{\i dwEpiStart}{, \line \tab }{\b UINT }{\i uNumSamples, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Writes a }{\ul\cf11 sweep}{\v Sweep}{ of data into a previously opened data file. The data buffer must contain all channels multiplexed together.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file being written.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uFlags\cell }{Flags governing the write process.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pvBuffer}{\cell Data buffer for the data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpiStart}{\cell Start time in samples of this }{\ul\cf11 sweep}{\v Sweep}{.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uNumSamples}{\cell Number of valid points in the data buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_MultiplexWrite}{ function writes the sweep of data from }{\i pvBuffer}{ into }{\i hFile}{. If the ABF_APPEND flag is set for an ABF_VARLENEVENTS mode file the data is appended to the previous }{\ul\cf11 sweep}{\v Sweep}{ in the data file being written.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EDISKFULL}{\cell Not enough space on disk.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b34000000000000000000000000000105000000000000}{\result {BOOL CopyDataFile(char *pszFileIn, int nFileIn, ABFFileHeader *pFI, 
\par                   char *pszFileOut, int nFileOut, ABFFileHeader *pFO)
\par \{
\par    UINT uNumSamples = (UINT)pFI->lNumSamplesPerEpisode;
\par    DWORD dwEpiStart, dwMissingSamples;
\par    
\par    short *pnBuffer = (short *)malloc(uNumSamples * sizeof(short));
\par    if (!pnBuffer)
\par    \{
\par       printf("Out of memory!\\n");
\par       return FALSE;
\par    \}
\par    
\par    for (DWORD i=1; i<=(DWORD)pFI->lActualEpisodes; i++)
\par    \{
\par       UINT uFlag = 0;
\par       int nError = 0;
\par       if (!ABF_MultiplexRead( nFileIn, pFI, i, pnBuffer, &uNumSamples,
\par                               &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par    
\par       if (!ABF_SynchCountFromEpisode( nFileIn, pFI, i, &dwEpiStart, 
\par                                  &nError ))
\par          return ShowABFError(pszFileIn, nError);
\par       if (pFI->nOperationMode == ABF_VARLENEVENTS)
\par       \{
\par          if (!ABF_GetMissingSynchCount( nFileIn, pFI, I,
\par                                      &dwMissingSynchCount, &nError ))
\par             return ShowABFError(pszFileIn, nError);
\par          if (dwMissingSynchCount == 0)
\par             uFlag = ABF_APPEND;
\par       \}
\par       if (!ABF_MultiplexWrite( nFileOut, pFO, uFlag, pnBuffer,
\par                                dwEpiStart, uNumSamples, &nError ))
\par          return ShowABFError(pszFileOut, nError);
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_MultiplexRead}{\v ABF_MultiplexRead}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadChannel}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadChannel}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadChannel}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadChannel
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_ReadChannel}{( }{\b int}{ }{\i hFile}{, }{\b ABFFileHeader *}{pFH, \line \tab }{\b int}{ }{\i nChannel}{, }{\b DWORD}{ }{\i dwEpisode}{, }{\b float *}{\i pfBuffer}{, \line \tab }{\b UINT *}{\i puNumSamples, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Reads a }{\ul\cf11 sweep}{\v Sweep}{ of data for a particular channel from a previously opened data file.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1939\clvertalt\cltxlrtb \cellx6475\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header for the file being read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1939\clvertalt\cltxlrtb \cellx6475\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nChannel\cell }{Physical channel number to be read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode\cell }{Sweep number to be read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pfBuffer\cell }{Data buffer for the data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i puNumSamples\cell }{Number of valid points in the data buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_ReadChannel}{ function reads }{\ul\cf11 sweep}{\v Sweep}{ number }{\i dwEpisode}{ of channel }{\i nChannel}{ from }{\i hFile}{ into }{\i pfBuffer}{. The actual number of points read into the buffer is returned in }{\i *puNumSamples}{. If the data in the file is in two-byte binary format, it is converted into fully scaled 4-byte floats in }{\ul\cf11 UserUnits}{\v User_Units}{.
{\v0\par\v}It is up to the user of this routine to ensure that the buffer passed in as pvBuffer points to an array of sufficient size to contain the returned sweep.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EWRITEONLYFILE}{\cell This file is write-only.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2932\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EINVALIDCHANNEL}{\cell Channel number is invalid.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b33000000000000000000000000000105000000000000}{\result {int ReadChannelEpisode( char *pszFileName, int nChannel,
\par                         DWORD dwEpisode, float *pfBuffer, 
\par                         UINT *puNumSamples )
\par \{
\par    int hFile;
\par    int nError;
\par    ABFFileHeader FH;
\par 
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 16 * 1024;
\par    if (!ABF_ReadOpen(pszFileName, &hFile, ABF_DATAFILE, &FH,
\par                      &uMaxSamples, &dwMaxEpi, &nError))
\par       return ShowABFError(pszFileName, nError);
\par    
\par    if (!ABF_ReadChannel( hFile, &FH, nChannel, dwEpisode, pfBuffer,
\par                          puNumSamples, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_MultiplexRead}{\v ABF_MultiplexRead}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadDACFileEpi}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadDACFileEpi}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadDACFileEpi}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadDACFileEpi
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_ReadDACFileEpi( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{,\line \tab }{\b short *}{\i pnDACArray}{, }{\b DWORD}{ }{\i dwEpisode, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Reads a }{\ul\cf11 sweep}{\v Sweep}{ from the }{\ul\cf11 DAC}{\v DAC_D_A}{ file section of an ABF file.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnDACArray}{\cell Data buffer for the data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode\cell }{Sweep number to be read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_ReadDACFileEpi}{ function reads }{\ul\cf11 sweep}{\v Sweep}{ number }{\i dwEpisode}{ from the DAC file section of }{\i hFile}{ into }{\i pnDACArray}{..
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2791\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2791\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADDACEPISODE}{\cell Could not read data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par 
\par BOOL ShowDACFileData(char *pszFileName, int nFile, ABFFileHeader *pFH,
\par                      short *pnBuffer)
\par \{
\par    int nError;
\par    DWORD i;
\par    UINT j;
\par    UINT uNumSamples = (UINT)pFH->lNumSamplesPerEpisode;
\par    
\par    for (i = 0; i < (DWORD)pFH->lDACFileNumEpisodes; i++)
\par    \{
\par       if (!ABF_ReadDACFileEpi( nFile, pFH, pnBuffer, i, &nError ))
\par          return ShowABFError(pszFileName, nError);
\par       for (j = 0; j < uNumSamples; j++)
\par          printf( "%d\\n", pnBuffer[j] );
\par    \}
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_WriteDACFileEpi}{\v ABF_WriteDACFileEpi}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadOpen}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadOpen}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadOpen}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadOpen
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_ReadOpen( char *}{\i szFileName}{\b , int *}{\i phFile}{\b , UINT }{\i uFlags}{\b ,\line \tab ABFFileHeader *}{\i pFH}{\b , UINT *}{\i puMaxSamples}{\b ,\line \tab DWORD *}{\i pdwMaxEpi, }{\b int *}{\i pnError }{\b );}{
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Opens an existing ABF data file for reading. Reads the acquisition parameters from the file header into the passed ABFFileHeader structure.
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6759\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i szFileName\cell }{Name of data file to open.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i phFile}{\cell Pointer to ABF file handle of this file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uFlags\cell }{Flag to indicate whether file is parameter file or not.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters read from data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i puMaxSamples}{\cell Pointer to requested size of data blocks to be returned.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pdwMaxEpi}{\cell Pointer to number of sweeps that exist in the data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6759\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\adjustright {
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Legal values for uFlags\cell \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_DATAFILE\cell File is data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_PARAMFILE\cell File is parameter file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {ABF_ALLOWOVERLAP\cell Permit return of overlapping data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_ReadOpen}{ function opens the data file }{\i szFileName, }{allocates an ABF file handle for it and assigns this number to }{\i *phFile}{. Data is read from the file header into }{\i *pFH}{. If }{\b ABF_PARAMFILE}{ is set in }{\i uFlags}{ then no further processing is performed, otherwise internal buffers are allocated in preparation for file reading.
\par For ABF_GAPFREEFILE and ABF_VARLENEVENTS files, }{\i *puMaxSamples}{ is passed in as a requested maximum size of the blocks of data returned by the ABF_ReadMultiplex and ABF_ReadChannel routines. For all modes, the actual value that will be used is returned in this location.
\par For Event Detected modes, on calling ABF_ReadOpen, the parameter }{\i pdwMaxEpi}{ points to a the maximum number of sweeps to read from the file. If it is zero the maximum will be 8192 sweeps, depending on RAM availability.  The total number of data blocks of the size returned in *}{\i puMaxSamples }{is returned in }{\i *pdwMaxEpi}{.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_TOOMANYFILESOPEN}{\cell Too many files are already open.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EOPENFILE}{\cell Failed DOS open file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EUNKNOWNFILETYPE}{\cell Could not recognise file type, possibly not an ABF file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADPARAMETERS}{\cell Could not read parameter header, possibly corrupted header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODESIZE}{\cell *pdwMaxSamples out of range i.e. below 128.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_OUTOFMEMORY}{\cell Could not allocate internal buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b32000000000000000000000000000105000000000000}{\result {BOOL FindAnEpisode( char *pszFileName, DWORD *pdwSample, 
\par                     DWORD *pdwEpisode )
\par \{
\par    int hFile;
\par    int nError = 0;
\par    ABFFileHeader FH;
\par    
\par    DWORD dwMaxEpi = 0;
\par    UINT uMaxSamples = 16 * 1024;
\par    
\par    if (!ABF_ReadOpen( pszFileName, &hFile, ABF_DATAFILE,
\par                       &FH, &uMaxSamples, &dwMaxEpi, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    
\par    if (!ABF_EpisodeFromSynchCount( hFile, &FH, pdwSynchCount, pdwEpisode, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ \line }{\uldb\cf11 ABF_Close}{\v ABF_Close}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadRawChannel}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadRawChannel}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadRawChannel}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadRawChannel
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_ReadRawChannel(int }{\i nFile}{, }{\b ABFFileHeader *}{\i pFH}{,}{\b  int }{\i nChannel}{, }{\b DWORD}{ }{\i dwEpisode}{,\line \tab }{\b void *}{\i pvBuffer}{, }{\b UINT *}{\i puNumSamples}{, }{\b int *}{\i pnError}{);
\par Reads a complete multiplexed }{\ul\cf11 sweep}{\v Sweep}{ from the data file and then decimates it, returning single de-multiplexed channel in the raw data format.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i nChannel\cell }{Channel to read the data for.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwEpisode}{\cell Sweep/chunk number to read.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pvBuffer\cell }{Buffer to return the raw, de-multiplexed data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i puNumSamples\cell }{Size of buffer pointed to by }{\i pvBuffer}{.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The required size of the passed buffer is:
\par pFH->lNumSamplesPerEpisode / pFH->nADCNumChannels   (shorts)
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx6804\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx6804\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EINVALIDCHANNEL\cell }{The requested channel was not in the sampling list.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_OUTOFMEMORY\cell }{Insufficient memory was available for use internally.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EEPISODERANGE\cell }{Sweep number out of range.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADDATA\cell }{Could not read }{\ul\cf11 sweep}{\v Sweep}{ data from file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx6804\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX\cell }{Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_ReadChannel}{\v ABF_ReadChannel}{ 
{\v0\par\v}}{\uldb\cf11 ABF_MultiplexRead}{\v ABF_MultiplexRead}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadScopeConfig}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadScopeConfig}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadScopeConfig}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadScopeConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_ReadScopeConfig(int }{\i nFile}{,}{\b  ABFFileHeader *}{\i pFH}{, }{\b ABFScopeConfig *}{\i pCfg}{, \line \tab }{\b UINT}{ }{\i uMaxScopes}{, }{\b int *}{\i pnError}{)
\par Retrieves the scope configuration info from the data file.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_ReadTags}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_ReadTags}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_ReadTags}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_ReadTags
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_ReadTags( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{, \line \tab }{\b DWORD}{ dwFirstTag, }{\b ABFTag *}{\i pTagArray, }{\b UINT }{\i uNumTags}{\b , \line \tab int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Reads a segment of the tag array from the TAGArray section.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwFirstTag\cell }{Index of the start of the sub array to retrieve\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pTagArray}{\cell Data buffer for the tag array.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uNumTags\cell }{Number of tag entries to retrieve.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_ReadTags}{ function reads a segment of the tag array from the TagArray section of }{\i hFile}{ into }{\i pTagArray}{.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADTAG\cell }{Could not read data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par #define TAG_BLOCKSIZE  10
\par int PrintTags( int hFile, char *pszFileName, ABFFileHeader *pFH )
\par \{
\par    ABFTag *pTagArray;
\par    UINT i;
\par    int nError;
\par    
\par    if (pFH->lNumTagEntries < 1)
\par       return TRUE;
\par    pTagArray = (ABFTag *)calloc( TAG_BLOCKSIZE, sizeof(ABFTag) );
\par    DWORD dwTagCount = pFH->lNumTagEntries;
\par    DWORD dwFirstTag = 0;
\par    while (dwTagCount)
\par    \{
\par       UINT uTags = (TAG_BLOCKSIZE > dwTagCount ? 
\par                    (UINT)dwTagCount : TAG_BLOCKSIZE);
\par       if (!ABF_ReadTags( hFile, pFH, dwFirstTag, pTagArray, uTags,
\par                          &nError ))
\par       \{
\par          free(pTagArray);
\par          return ShowABFError(pszFileName, nError);
\par       \}
\par       for (i = 0; i < uTags; i++)
\par          printf( "\\nTime: %ld Type: %d\\n%56.56s\\n", 
\par               pTagArray[i].lTagTime, pTagArray[i].nTagType,
\par               pTagArray[i].sComment );
\par       dwTagCount -= uTags;
\par       dwFirstTag += uTags;
\par    \}
\par    free(pTagArray);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_WriteTag}{\v ABF_WriteTag}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_SetErrorCallback}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_SetErrorCallback}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_SetErrorCallback}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_SetErrorCallback
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b typedef BOOL (AXOAPI *}{\i ABFCallback}{\b )(void *}{\i pvThisPointer}{, }{\b int}{ }{\i nError}{);
\par }{\b BOOL ABF_SetErrorCallback(int }{\i nFile}{, }{\b ABFCallback }{\i fnCallback}{, }{\b void *}{\i pvThisPointer}{,}{\b  int *}{\i pnError}{)
\par This routine sets a callback function to be called in the event of an error occuring.
\par 
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_UpdateAfterAcquisition}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_UpdateAfterAcquisition}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_UpdateAfterAcquisition}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_UpdateAfterAcquisition
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_UpdateAfterAcquisition( ABFFileHeader *}{pFH, \line \tab }{\b DWORD }{\i dwAcquiredEpisodes}{, }{\b DWORD}{ dw}{\i AcquiredSamples, \line \tab }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Update the ABF internal housekeeping after data has been written into a data file without using the ABF file I/O routines. This function should not need to be called if all access to ABF files are performed through the ABF file routines. It is provided for debugging purposes and for acquisition programs that do their own file I/O for performance reasons.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile\cell }{ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH\cell }{File header returned from the ABF_WriteOpen call for this file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwAcquiredEpisodes}{\cell Number of acquired sweeps.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwAcquiredSamples}{\cell Number of acquired samples.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2223\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_UpdateAfterAcquisition}{ function updates ABF internal housekeeping of acquired data. This function must be called before ABF_UpdateHeader if the file has been written to via the handle obtained by }{\uldb\cf11 ABF_GetFileHandle}{\v ABF_GetFileHandle}{ .
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2791\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2791\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Invalid ABF file handle specified.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b35000000000000000000000000000105000000000000}{\result {BOOL Acquisition( char *pszFileName, ABFFileHeader *pFH )
\par \{
\par    int hFile;
\par    HANDLE hHandle;
\par    int nError = 0;
\par    DWORD dwEpisodes, dwSamples;
\par    
\par    if (!ABF_WriteOpen( pszFileName, &hFile, ABF_DATAFILE, pFH, 
\par                        &nError ) )
\par       return ShowABFError(pszFileName, nError);
\par    if (!ABF_GetFileHandle( hFile, &hHandle, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    AcquireAndWriteData( hHandle, pFH, &dwEpisodes, &dwSamples );
\par    if (!ABF_UpdateAfterAcquisition( hFile, pFH, dwEpisodes, dwSamples,
\par                                     &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_UpdateHeader( hFile, pFH, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_UpdateHeader}{\v ABF_UpdateHeader}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_UpdateHeader}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_UpdateHeader}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_UpdateHeader}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_UpdateHeader
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_UpdateHeader( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH, }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Updates the file header to reflect the data newly written into an ABF data file.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_UpdateHeader}{ function updates the file header and writes the synch array out to disk if required. This function should always be called before closing a file opened with ABF_WriteOpen.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3420\clvertalt\cltxlrtb \cellx6840\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EWRITEPARAMETERS}{\cell Could not write header parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b35000000000000000000000000000105000000000000}{\result {BOOL Acquisition( char *pszFileName, ABFFileHeader *pFH )
\par \{
\par    int hFile;
\par    HANDLE hHandle;
\par    int nError = 0;
\par    DWORD dwEpisodes, dwSamples;
\par    
\par    if (!ABF_WriteOpen( pszFileName, &hFile, ABF_DATAFILE, pFH, 
\par                        &nError ) )
\par       return ShowABFError(pszFileName, nError);
\par    if (!ABF_GetFileHandle( hFile, &hHandle, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    AcquireAndWriteData( hHandle, pFH, &dwEpisodes, &dwSamples );
\par    if (!ABF_UpdateAfterAcquisition( hFile, pFH, dwEpisodes, dwSamples,
\par                                     &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_UpdateHeader( hFile, pFH, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{ \line }{\uldb\cf11 ABF_Close}{\v ABF_Close}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteDACFileEpi}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteDACFileEpi}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteDACFileEpi}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_WriteDACFileEpi
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_WriteDACFileEpi( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{,\line \tab }{\b short *}{\i pnDACArray, }{\b int *}{\i pnError )}{;
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Writes a sweep to the }{\ul\cf11 DAC}{\v DAC_D_A}{ file section.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnDACArray}{\cell Data buffer of the data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteDACFileEpi}{ function writes a }{\ul\cf11 sweep}{\v Sweep}{ from }{\i pnDACArray }{to the DAC file section of }{\i hFile}{.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EWRITEDACEPISODE}{\cell Could not write data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_ReadDACFileEpi}{\v ABF_ReadDACFileEpi}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteOpen}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteOpen}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteOpen}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_WriteOpen
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_WriteOpen( char *}{\i szFileName}{\b , int *}{\i phFile}{\b , UINT }{\i uFlags}{\b ,\line \tab ABFFileHeader *}{\i pFH, }{\b int *}{\i pnError }{\b );}{
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Opens an existing data }{\ul\cf11 file}{\v File}{ for writing. Writes the acquisition parameters.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i szFileName\cell }{Name of data file to open.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i phFile}{\cell Pointer to ABF file handle of this file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i uFlags\cell }{Flag to indicate whether file is parameter file or not.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters to be written to data file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteOpen}{ function opens the data }{\ul\cf11 file}{\v File}{ }{\i szFileName, }{allocates an ABF file handle for it and assigns this number to }{\i *phFile}{. The contents of }{\i *pFH}{ are written to the file header.
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_TOOMANYFILESOPEN}{\cell Too many data files are already open.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EOPENFILE}{\cell Failed DOS open file.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EWRITEPARAMETERS}{\cell Could not write parameter header.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_OUTOFMEMORY}{\cell Could not allocate decollation buffer.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EDISKFULL}{\cell Not enough space on disk.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Example
\par }\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {#include "abffiles.h"
\par }{\pard\plain \s23\nowidctlpar\widctlpar\adjustright \f2\fs18\cgrid {\object\objautlink\rsltmerge\rsltrtf{\*\objclass Word.Document.8}{\*\objdata 010500000100000010000000576f72642e446f63756d656e742e38002d000000433a5c41786f6e4465765c436f6d705c417841626646696f33325c444f43535c41424646494c45532e646f63000a0000004444455f4c494e4b35000000000000000000000000000105000000000000}{\result {BOOL Acquisition( char *pszFileName, ABFFileHeader *pFH )
\par \{
\par    int hFile;
\par    HANDLE hHandle;
\par    int nError = 0;
\par    DWORD dwEpisodes, dwSamples;
\par    
\par    if (!ABF_WriteOpen( pszFileName, &hFile, ABF_DATAFILE, pFH, 
\par                        &nError ) )
\par       return ShowABFError(pszFileName, nError);
\par    if (!ABF_GetFileHandle( hFile, &hHandle, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    AcquireAndWriteData( hHandle, pFH, &dwEpisodes, &dwSamples );
\par    if (!ABF_UpdateAfterAcquisition( hFile, pFH, dwEpisodes, dwSamples,
\par                                     &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_UpdateHeader( hFile, pFH, &nError ))
\par    \{
\par       ABF_Close( hFile, NULL );
\par       return ShowABFError(pszFileName, nError);
\par    \}
\par    if (!ABF_Close( hFile, &nError ))
\par       return ShowABFError(pszFileName, nError);
\par    return TRUE;
\par \}
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid }}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ \line }{\uldb\cf11 ABF_Close}{\v ABF_Close}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteRawData}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteRawData}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteRawData}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_WriteRawData
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_WriteRawData( int}{ }{\i hFile}{, }{\b void *}{\i pvBuffer, }{\b DWORD }{\i dwSizeInBytes, }{\b int *}{\i pnError )}{;
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Writes a raw data buffer to the ABF }{\ul\cf11 file}{\v File}{ at the current file position.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pvBuffer}{\cell Pointer to the buffer of data to write.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i dwSizeInBytes}{\cell The amount (in bytes) of data to write.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1798\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {This routine writes a raw buffer of binary data to the current position of an ABF file previously opened with a call to }{\uldb\cf11 ABF_WriteOpen}{\v ABF_WriteOpen}{. This routine is provided for acquisition programs that buffer up episodic data and then write it out in large chunks. This provides an alternative to retrieving the low-level file handle and acting on it, as this can be non-portable, and assumptions would have to be made regarding the type of file handle returned (DOS or \ldblquote C\rdblquote  runtime).
{\v0\par\v}}\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EDISKFULL}{\cell The destination drive is out of disk space.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EREADONLYFILE}{\cell File was opened with }{\uldb\cf11 ABF_ReadOpen}{\v ABF_ReadOpen}{ \cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx3074\clvertalt\cltxlrtb \cellx6494\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EBADFILEINDEX}{\cell Bad ABF file handle passed in.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_MultiplexWrite}{\v ABF_MultiplexWrite}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteScopeConfig}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteScopeConfig}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteScopeConfig}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_WriteScopeConfig
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b BOOL ABF_WriteScopeConfig(int }{\i nFile}{\b , ABFFileHeader *}{\i pFH}{, }{\b int}{ }{\i nScopes}{, \line \tab }{\b ABFScopeConfig *}{\i pCfg}{, }{\b int *}{pnError)
\par Saves the current scope configuration info to the data file.
\par }\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABF_WriteTag}}}{ }{\cs21\super ${\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABF_WriteTag}}}{ }{\cs21\super K{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABF_WriteTag}}}{ }{\cs21\super +{\footnote \pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABF_WriteTag
\par }\pard\plain \sb240\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b #include "abffiles.h"}{
\par }\pard \sb120\nowidctlpar\widctlpar\adjustright {\b BOOL ABF_WriteTag( int}{ }{\i hFile}{, }{\b ABFFileHeader *}{\i pFH}{, }{\b ABFTag *}{\i pTag}{, \line \tab }{\b int *}{\i pnError }{);
\par }\pard \sb240\nowidctlpar\widctlpar\adjustright {Writes a tag value to the TAGArray section.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Parameter\cell Description\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i hFile}{\cell ABF file handle.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pFH}{\cell Pointer to acquisition parameters.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pTag}{\cell Data buffer of the tag array.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx1940\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\i pnError\cell }{Address of error return code. May be NULL.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Comments
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {The }{\b ABF_WriteTag}{ function writes a single ABFTag structure to the ABF file. All tags are internally buffered to disk inside the ABFFILES module and written out to the file when ABF_UpdateHeader() is called.
\par }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {Possible Error Codes
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {One of the following error codes may be returned on error (defined in ABFFILES.H).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx2507\clvertalt\cltxlrtb \cellx6476\pard \sb240\nowidctlpar\widctlpar\intbl\adjustright {\b Constant\cell Meaning\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2507\clvertalt\cltxlrtb \cellx6476\pard \sb120\nowidctlpar\widctlpar\intbl\adjustright {\b ABF_EWRITETAG\cell }{Could not write data.\cell }\pard \nowidctlpar\widctlpar\intbl\adjustright {\row }\pard\plain \s22\sb240\nowidctlpar\widctlpar\adjustright \b\f1\fs22\cgrid {See Also:
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 ABF_ReadTags}{\v ABF_ReadTags}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\nowidctlpar\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs21\super #{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super #}{ ABFCallback}}}{ }{\cs21\super ${\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super $}{ ABFCallback}}}{ }{\cs21\super K{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super K}{ ABFCallback}}}{ }{\cs21\super +{\footnote \pard\plain \s24\sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\cs21\super +}{ ABFFUNC}}}{ ABFCallback
\par }\pard\plain \sb120\nowidctlpar\widctlpar\adjustright \f1\fs20\cgrid {\b typedef BOOL (AXOAPI *}{\i ABFCallback}{\b )(void *}{\i pvThisPointer}{, }{\b int}{ }{\i nError}{);
\par 
\par }}
