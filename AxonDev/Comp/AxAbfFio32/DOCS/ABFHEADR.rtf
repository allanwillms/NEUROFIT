{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033{\fonttbl{\f0\froman\fcharset0\fprq2 Times New Roman;}{\f1\fswiss\fcharset0\fprq2 Arial;}{\f2\fmodern\fcharset0\fprq1 Courier New;}{\f3\froman\fcharset2\fprq2 Symbol;}{\f4\froman\fcharset0\fprq2 Times;}{\f5\fswiss\fcharset0\fprq2 Helvetica;}{\f6\fmodern\fcharset0\fprq1 Courier;}{\f7\fswiss\fcharset0\fprq2 Geneva;}{\f8\froman\fcharset0\fprq2 Tms Rmn;}{\f9\fswiss\fcharset0\fprq2 Helv ;}{\f10\froman\fcharset0\fprq2 MS Serif;}{\f11\fswiss\fcharset0\fprq2 MS Sans Serif;}{\f12\froman\fcharset0\fprq2 New York;}{\f13\fswiss\fcharset0\fprq2 System;}{\f14\fnil\fcharset2\fprq2 Wingdings;}{\f15\fswiss\fcharset0\fprq2 Tahoma;}{\f16\froman\fcharset0\fprq2 CG Times (WN);}{\f17\fmodern\fcharset0\fprq1 LinePrinter;}{\f18\froman\fcharset0\fprq2 CG Times;}{\f19\fswiss\fcharset0\fprq2 Univers;}{\f20\fnil\fcharset2\fprq2 Marlett;}{\f21\fswiss\fcharset0\fprq2 Haettenschweiler;}{\f22\froman\fcharset2\fprq2 MT Extra;}{\f23\fswiss\fcharset0\fprq2 Arial Narrow;}{\f24\fswiss\fcharset0\fprq2 Arial Black;}{\f25\froman\fcharset0\fprq2 Bookman Old Style;}{\f26\fnil\fcharset2\fprq2 Monotype Sorts;}{\f27\froman\fcharset0\fprq2 Map Symbols;}{\f28\froman\fcharset0\fprq2 Garamond;}{\f29\fswiss\fcharset0\fprq2 Impact;}{\f30\fnil\fcharset2\fprq2 MS Outlook;}{\f31\fscript\fcharset0\fprq2 Comic Sans MS;}{\f32\froman\fcharset2\fprq2 Bookshelf Symbol 3;}{\f33\fswiss\fcharset2\fprq2 Bookshelf Symbol 4;}{\f34\fnil\fcharset2\fprq2 Bookshelf Symbol 5;}{\f35\fswiss\fcharset0\fprq2 News Gothic MT;}{\f36\fscript\fcharset0\fprq2 Lucida Handwriting;}{\f37\fswiss\fcharset0\fprq2 Lucida Sans;}{\f38\fswiss\fcharset0\fprq2 Lucida Sans Unicode;}{\f39\froman\fcharset0\fprq2 Book Antiqua;}{\f40\fswiss\fcharset0\fprq2 Century Gothic;}{\f41\fmodern\fcharset0\fprq1 OCR A Extended;}{\f42\froman\fcharset0\fprq2 Calisto MT;}{\f43\fswiss\fcharset0\fprq2 Abadi MT Condensed Light;}{\f44\fswiss\fcharset0\fprq2 Copperplate Gothic Bold;}{\f45\fswiss\fcharset0\fprq2 Copperplate Gothic Light;}{\f46\fmodern\fcharset0\fprq1 Lucida Console;}{\f47\fswiss\fcharset0\fprq2 Verdana;}{\f48\froman\fcharset2\fprq2 Webdings;}{\f139\fswiss\fcharset238\fprq2 Tahoma CE;}{\f140\fswiss\fcharset204\fprq2 Tahoma Cyr;}{\f142\fswiss\fcharset161\fprq2 Tahoma Greek;}{\f143\fswiss\fcharset162\fprq2 Tahoma Tur;}{\f144\fswiss\fcharset186\fprq2 Tahoma Baltic;}{\f187\fswiss\fcharset238\fprq2 Arial Narrow CE;}{\f188\fswiss\fcharset204\fprq2 Arial Narrow Cyr;}{\f190\fswiss\fcharset161\fprq2 Arial Narrow Greek;}{\f191\fswiss\fcharset162\fprq2 Arial Narrow Tur;}{\f192\fswiss\fcharset186\fprq2 Arial Narrow Baltic;}{\f193\fswiss\fcharset238\fprq2 Arial Black CE;}{\f194\fswiss\fcharset204\fprq2 Arial Black Cyr;}{\f196\fswiss\fcharset161\fprq2 Arial Black Greek;}{\f197\fswiss\fcharset162\fprq2 Arial Black Tur;}{\f198\fswiss\fcharset186\fprq2 Arial Black Baltic;}{\f199\froman\fcharset238\fprq2 Bookman Old Style CE;}{\f200\froman\fcharset204\fprq2 Bookman Old Style Cyr;}{\f202\froman\fcharset161\fprq2 Bookman Old Style Greek;}{\f203\froman\fcharset162\fprq2 Bookman Old Style Tur;}{\f204\froman\fcharset186\fprq2 Bookman Old Style Baltic;}{\f217\froman\fcharset238\fprq2 Garamond CE;}{\f218\froman\fcharset204\fprq2 Garamond Cyr;}{\f220\froman\fcharset161\fprq2 Garamond Greek;}{\f221\froman\fcharset162\fprq2 Garamond Tur;}{\f222\froman\fcharset186\fprq2 Garamond Baltic;}{\f223\fswiss\fcharset238\fprq2 Impact CE;}{\f224\fswiss\fcharset204\fprq2 Impact Cyr;}{\f226\fswiss\fcharset161\fprq2 Impact Greek;}{\f227\fswiss\fcharset162\fprq2 Impact Tur;}{\f228\fswiss\fcharset186\fprq2 Impact Baltic;}{\f277\fswiss\fcharset238\fprq2 Lucida Sans Unicode CE;}{\f278\fswiss\fcharset204\fprq2 Lucida Sans Unicode Cyr;}{\f280\fswiss\fcharset161\fprq2 Lucida Sans Unicode Greek;}{\f281\fswiss\fcharset162\fprq2 Lucida Sans Unicode Tur;}{\f325\fmodern\fcharset238\fprq1 Lucida Console CE;}{\f326\fmodern\fcharset204\fprq1 Lucida Console Cyr;}{\f328\fmodern\fcharset161\fprq1 Lucida Console Greek;}{\f329\fmodern\fcharset162\fprq1 Lucida Console Tur;}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{\sb120\widctlpar\adjustright \f1\fs20\cgrid \snext0 Normal;}{\s1\sb60\sa120\keepn\widctlpar\adjustright \b\f1\fs28\cgrid \sbasedon0 \snext0 heading 1;}{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\i\f1\cgrid \sbasedon0 \snext0 heading 2;}{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\i\f1\cgrid \sbasedon0 \snext0 heading 4;}{\s5\sb240\sa60\widctlpar\adjustright \f1\fs22\cgrid \sbasedon0 \snext0 heading 5;}{\s6\sb240\sa60\widctlpar\adjustright \i\f1\fs22\cgrid \sbasedon0 \snext0 heading 6;}{\*\cs10 \additive Default Paragraph Font;}{\s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid \sbasedon0 \snext0 SubHeading;}{\s16\li74\ri74\sb40\sa40\widctlpar\adjustright \f1\fs22\cgrid \sbasedon0 \snext16 TableText;}{\s17\li74\ri74\sb120\sa60\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext17 TableHeading;}{\s18\widctlpar\adjustright \f2\fs18\cgrid \sbasedon0 \snext18 Source;}{\s19\sb120\widctlpar\adjustright \f9\fs20\cgrid \sbasedon0 \snext19 footnote text;}{\*\cs20 \additive \super \sbasedon10 footnote reference;}{\s21\widctlpar\adjustright \f2\fs16\cgrid \sbasedon18 \snext21 SourceFile;}{\s22\widctlpar\adjustright \f2\fs20\cgrid \sbasedon0 \snext22 Plain Text;}}{\*\revtbl {Unknown;}}{\info{\title # $ K + The ABF Header Section}{\author Bruce Ikin}{\operator Philip Churchward}{\creatim\yr1998\mo6\dy9\hr16\min5}{\revtim\yr1998\mo6\dy9\hr16\min5}{\version2}{\edmins0}{\nofpages49}{\nofwords11530}{\nofchars65726}{\*\company Axon Research}{\nofcharsws80716}{\vern89}}\paperw11907\paperh16840\margl1134\margr1134\margt1134\margb1134 \widowctrl\ftnbj\aenddoc\makebackup\lytprtmet\formshade\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot \fet0{\*\template C:\\MSOFFICE\\WINWORD\\ROBORTF.DOT}\sectd \psz9\linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl {\*\pnseclvl1\pnucrm\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang{\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang{\pntxta )}}{\*\pnseclvl5\pndec\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang{\pntxtb (}{\pntxta )}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ The_ABF_Header_Section}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ The ABF Header Section}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ The ABF Header Section}}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Header Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {The ABF header is the first block of data at the start of an ABF data }{\ul\cf11 file}{\v File}{.  The header contains parameters that describe the stimulation, the acquisition and the }{\ul\cf11 hierarchy}{\v Hierarchy}{ of the data.  It describes the contents of the data file and contains entries to describe the settings in effect when the data file was acquired.
{\v0\par\v}In version 1.5, the header is 2048 bytes long.  This will most likely be increased in subsequent versions.  Third party programs should NOT rely on the size of the header, or retrieve information based on a byte offset. Only use the documented variables defined in the header.
{\v0\par\v}See the file }{\uldb\cf11 ABFHEADR.H}{\v ABFHEADR_H}{ for a \ldblquote C\rdblquote  definition of the ABFFileHeader structure.
{\v0\par\v}}\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {ABF Header Sub Sections
\par }\trowd \trgaph108\trleft-108 \clvertalt\cltxlrtb \cellx3119\clvertalt\cltxlrtb \cellx7938\pard\plain \sb120\widctlpar\intbl\tx340\adjustright \f1\fs20\cgrid {1.\tab }{\uldb\cf11 File ID and Size information}{\v File_ID_and_Size_information}{ \cell 9.\tab }{\uldb\cf11 Epoch Waveform and Pulses}{\v Epoch_Waveform_and_Pulses}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trgaph108\trleft-108 \clvertalt\cltxlrtb \cellx3119\clvertalt\cltxlrtb \cellx7938\pard \sb120\widctlpar\intbl\tx340\adjustright {2.\tab }{\uldb\cf11 File Structure}{\v File_Structure}{ \cell 10.\tab }{\uldb\cf11 DAC Output File}{\v DAC_Output_File}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\tx340\adjustright {3.\tab }{\uldb\cf11 Trial Hierarchy Information}{\v Trial_Hierarchy_Information}{ \cell 11.\tab }{\uldb\cf11 Conditioning pulse train}{\v Conditioning_pulse_train}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\tx340\adjustright {4.\tab }{\uldb\cf11 Display Parameters}{\v Display_Parameters}{ \cell 12.\tab }{\uldb\cf11 Variable Parameter User List}{\v Variable_Parameter_User_List}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\tx340\adjustright {5.\tab }{\uldb\cf11 Hardware Information}{\v Hardware_Information}{ \cell 13.\tab }{\uldb\cf11 Autopeak measurement}{\v Autopeak_measurement}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\tx340\adjustright {6.\tab }{\uldb\cf11 Environmental information}{\v Environmental_information}{ \cell 14.\tab }{\uldb\cf11 Channel Arithmetic}{\v Channel_Arithmetic}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\tx340\adjustright {7.\tab }{\uldb\cf11 Multi-channel information}{\v Multi_channel_information}{ \cell 15.\tab }{\uldb\cf11 On-line Subtraction}{\v On_line_Subtraction}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trgaph108\trleft-108 \clvertalt\cltxlrtb \cellx3119\clvertalt\cltxlrtb \cellx7938\pard \sb120\widctlpar\intbl\tx340\adjustright {8.\tab }{\uldb\cf11 Synchronous timer outputs}{\v Synchronous_timer_outputs}{ \cell 16.\tab }{\uldb\cf11 Unused space at end of header block}{\v Unused_space_at_end_of_header_block}{ \cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {The total header length = 2048 bytes.\tab \line Offsets in the lists referenced above are Byte offsets.
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {Notes:
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 Data Types}{\v Data_Types}{ \line }{\uldb\cf11 Version Numbers}{\v Version_Numbers}{ \line }{\uldb\cf11 ADC Channel Numbering}{\v ADC_Channel_Numbering}{ \line }{\uldb\cf11 Composite Values}{\v Composite_Values}{ \line }{\uldb\cf11 Indexing Arrays in the ABF Header}{\v Indexing_Arrays_in_the_ABF_Header}{ 
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ ADC_Channel_Numbering}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ ADC Channel Numbering}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ ADC Channel Numbering}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ }{\ul\cf11 ADC}{\v ADC_A_D}{ Channel Numbering
{\v0\par\v}}\pard\plain \sb120\widctlpar\tx1440\tx1584\tx3168\adjustright \f1\fs20\cgrid {Axon's data acquisition programs distinguish between physical and logical channel numbers. Physical channel numbers are the channel numbers used internally to communicate with the acquisition hardware.  Logical channel numbers are the external connector labels on the front panel of the acquisition hardware.  Logical channel numbers are used only for presentation to the user.  Physical channel numbers are used everywhere else.  For example, parameters are stored using physical channel number order (0 to 15) for such structures as the sampling }{\ul\cf11 sequence}{\v Sequence}{ array and the entries for the external lowpass and highpass filters.  Similarly, a physical channel number is used for the Trigger channel.  At the time of printing this document, the only digitizer known to have different physical and logical channel numbering is the (now obsolete) TL-2 interface.
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\b0\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ Indexing_Arrays_in_the_ABF_Header}}}{ }{\cs20\b0\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ Indexing Arrays in the ABF Header}}}{ }{\cs20\b0\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ Indexing Arrays in the ABF Header}}}{ }{\cs20\b0\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFHELP}}}{ Indexing Arrays in the ABF Header
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {To get a Logical channel number from a Physical channel number, simply index the nADCPtoLchannelMap array by the Channel number you wish to convert.  Thus nADCPtoLchannelMap[1] provides the Logical Channel Number for Physical Channel Number 1. This array is always symmetrical, so it can be used in the same way to convert back to Physical Channel Numbers from Logical Channel Numbers.
\par The first thing to look at is the nADCSamplingSeq array. This tells you which physical }{\ul\cf11 ADC}{\v ADC_A_D}{ channels were acquired and in what order.  The first entry in this array is the Physical channel number of the first ADC channel acquired, followed by the second etc.  There are nADCNumChannels channels in this array.  All ADC arrays except for the nADCSamplingSeq are indexed through Physical channel numbers. These include: sADCChannelName, sADCUnits, etc. 
{\v0\par\v}Special Note: All array indexing within the header and within the ABF routines start at 0, except Sweep number, which starts at 1.
{\v0\par\v}
{\v0\par\v}}\pard\plain \s18\widctlpar\adjustright \f2\fs18\cgrid {void ShowFirstAcquiredChannelInfo( int nFile, ABFFileHeader *pFH )
\par \{
\par    // Get first physical channel number and name
\par    int nFirstPhysicalChannel = pFH->nADCSamplingSeq[0];
\par    char *psSignalName = pFH->sADCChannelName[nFirstPhysicalChannel];
\par 
\par    // Get channel number to show to user
\par    int nFirstLogicalChannel = pFH->nADCPtoLchannelMap[nFirstPhysicalChannel];
\par    fprint(\ldblquote The first acquired channel (%s) comes from ADC channel %d\\n\rdblquote , \line           psSignalName, nFirstLogicalChannel);
\par 
\par    // Get start time of first episode of first channel
\par    int nFirstEpisode = 1;
\par    float fStartTime;
\par    ABF_GetStartTime(nFile, pFH, nFirstPhysicalChannel, nFirstEpisode, 
\par                     &fStartTime, NULL);
\par \}
\par }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Composite_Values}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Composite Values}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Composite Values}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Composite Values
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {Axon Instruments' acquisition programs can automatically read the gain and lowpass filter settings of the analog }{\ul\cf11 instrument}{\v Instrument}{ (e.g. patch clamp) on one }{\ul\cf11 ADC}{\v ADC_A_D}{ channel (nAutosampleADCNum).  If the ABF reading routines are used the autosampled gain must be taken into account when calculating the signal scale factor for the autosampled channel, as must the autosampled lowpass filter setting.  Both of these factors are automatically taken into account by the ABF reading routines.
{\v0\par\v}In some cases, several parameters must be considered together to correctly interpret the data.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx2694\clvertalt\cltxlrtb \cellx7371\pard \sb120\widctlpar\intbl\adjustright {Composite ADC scale factor\cell fInstrumentScaleFactor[n] * fAutosampleAdditGain * fADCProgrammableGain[n] * fSignalGain[n].
\par Note, the fAutosampleAdditGain only applies to the autosampled ADC channel.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2694\clvertalt\cltxlrtb \cellx7371\pard \sb120\widctlpar\intbl\adjustright {Composite ADC offset\cell fInstrumentOffset[n] + fSignalOffset[n]\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx2694\clvertalt\cltxlrtb \cellx7371\pard \sb120\widctlpar\intbl\adjustright {Composite lowpass filter -3 dB frequency\cell A complex function of fSignalLowpassFilter and fAutosampleFilter, for the autosampled ADC channel.  On other ADC channels, only the fSignalLowpassFilter contributes to the composite value.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {The functions }{\uldb\cf11 ABFH_GetADCtoUUFactors()}{\v ABFH_GetADCtoUUFactors}{ and }{\uldb\cf11 ABFH_GetDACtoUUFactors()}{\v ABFH_GetDACtoUUFactors}{ should be used to get the combined scale factors required for converting ADC/}{\ul\cf11 DAC}{\v DAC_D_A}{ values to }{\ul\cf11 UserUnits}{\v User_Units}{ and vice versa.
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Data_Types}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Data Types}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Data Types}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Data Types
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {Unused real parameters should be filled with zeros.  Unused strings should be filled with the space character (ASCII #32).
\par Parameters for unsampled }{\ul\cf11 ADC}{\v ADC_A_D}{ channels should be filled with the indicated default.
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Version_Numbers}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Version Numbers}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Version Numbers}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Version Numbers
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {The file version number consists of a major and a minor number.  For example, the "1" in Version 1.0 is the major number, and the "0" is the minor number.
\par In general, the major version number is updated when changes affect the byte offset of the existing parameters or would otherwise make the file unusable by existing programs.  The minor version number is updated when unused parameters are utilised.  In most cases, existing programs will not be affected since they should not be dependent upon the unused parameters.
\par }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\b0 \page }{\cs20\b0\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ ABF_Hardware_and_Storage_Limits}}}{ }{\cs20\b0\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ ABF Hardware and Storage Limits}}}{ }{\cs20\b0\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ ABF Hardware and Storage Limits}}}{ }{\cs20\b0\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFHELP}}}{ ABF Hardware and Storage Limits
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {Some of the more important limitations in the range of hardware supported and the size of components in ABF formatted }{\ul\cf11 files}{\v File }{are listed here.
{\v0\par\v}}\pard \fi-284\li284\sb120\widctlpar\tx284\adjustright {\bullet \tab Sixteen physical }{\ul\cf11 ADC}{\v ADC_A_D}{ channels, numbered 0-15.
{\v0\par\v}\bullet \tab Up to sixteen bits per ADC word.
{\v0\par\v}\bullet \tab Up to 16 K (16,384) multiplexed samples per }{\ul\cf11 sweep}{\v Sweep}{ in high-speed oscilloscope mode, }{\ul\cf11 fixed-length}{\v Fixed_Length_Event_Driven}{ event-driven mode and }{\ul\cf11 episodic stimulation}{\v Episodic_Stimulation}{ mode.
{\v0\par\v}\bullet \tab Up to 2 G multiplexed samples per segment in }{\ul\cf11 variable-length}{\v Variable_Length_Event_Driven}{ event-driven mode and }{\ul\cf11 gap-free}{\v Gap_Free}{ mode.
{\v0\par\v}\bullet \tab Stimulus waveform generated on one }{\ul\cf11 DAC}{\v DAC_D_A}{ channel only.
{\v0\par\v}\bullet \tab Conditioning train generated on one DAC channel only.
{\v0\par\v}\bullet \tab One Math Channel.
{\v0\par\v}\bullet \tab One Autosampled }{\ul\cf11 instrument}{\v Instrument}{.
{\v0\par\v}\bullet \tab One Leak Subtracted ADC channel.
{\v0\par\v}\bullet \tab One set of display amplifications and offsets.
{\v0\par\v}\bullet \tab Only one averaged Run per file!
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ File_ID_and_Size_information}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ File ID and Size information}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ File ID and Size information;lFileSignature;fFileVersionNumber;nOperationMode;lActualAcqLength;nNumPointsIgnored;lActualEpisodes;lFileStartDate;lFileStartTime;lStopwatchTime;fHeaderVersionNumber;nFileType;nMSBinFormat}}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ File ID and Size information
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(40 bytes)
\par These ten entries represent two types of information:  (1) File identification information;  (2) Parameters whose actual value may be different to the value requested before the acquisition commenced, e.g. due to a user abort.  The requested values are located elsewhere.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {0\cell lFileSignature\cell }{\ul\cf11 long}{\v long}{\cell File type used for format identification.  Possible values are:   "ABF ", "CLPX" and "FTCX".  Used to create the numbers in nFileType.\line (In old pCLAMP and Axotape data files, the first four bytes were a }{\ul\cf11 float}{\v float}{:\line    1 = CLAMPEX,\line    10 = FETCHEX/AxoTape.\line This is translated on reading into either CLPX or FTCX as appropriate.)\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {4\cell fFileVersionNumber\cell }{\ul\cf11 float}{\v float}{\cell File format version stored in the data file during acquisition.  The present version is 1.5.  (In old pCLAMP and Axotape data files, this parameter is in the range 2.0-5.3)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {8\cell nOperationMode\cell }{\ul\cf11 short}{\v short}{\cell Operation mode: 1 = Event-driven, variable length;  2 = Oscilloscope, loss free (Same as Event-driven, }{\ul\cf11 fixed length}{\v Fixed_Length_Event_Driven}{);  3 = Gap-free;  4 = Oscilloscope, high-speed;  5 = episodic stimulation (Clampex only).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {10\cell lActualAcqLength\cell }{\ul\cf11 long}{\v long}{\cell Actual number of }{\ul\cf11 ADC}{\v ADC_A_D}{ samples (aggregate) in data file.  See lAcqLength.  Averaged }{\ul\cf11 sweeps}{\v Sweep}{  are included.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {14\cell nNumPointsIgnored\cell }{\ul\cf11 short}{\v short}{\cell Number of points ignored at data start.  Normally zero, but non-zero for }{\ul\cf11 gap-free}{\v Gap_Free}{ acquisition using AXOLAB configurations with one or more ADS boards.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {16\cell lActualEpisodes\cell }{\ul\cf11 long}{\v long}{\cell Actual number of }{\ul\cf11 sweeps}{\v Sweep}{  in the file including averaged sweeps.  See lEpisodesPerRun.  If nOperationMode = 3 (}{\ul\cf11 gap-free}{\v Gap_Free}{) the value of this parameter is 1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {20\cell lFileStartDate\cell }{\ul\cf11 long}{\v long}{\cell Date when data portion of this file was first written to.  Stored as YYMMDD.  If YY is in the range 80-99, prefix with "19" to get the year.  If YY is in the range 00-79, prefix with "20" to get the year.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {24\cell lFileStartTime\cell }{\ul\cf11 long}{\v long}{\cell Time of day in seconds past midnight when data portion of this file was first written to.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {28\cell lStopwatchTime\cell }{\ul\cf11 long}{\v long}{\cell }\pard\plain \s19\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Time since the stopwatch was zeroed that the data portion of this file was first written to.  Not supported by all programs.  Default = 0.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard \sb120\widctlpar\intbl\adjustright {32\cell fHeaderVersionNumber\cell }{\ul\cf11 float}{\v float}{\cell Version number of the header structure returned by the ABF_ReadOpen function.  Currently 1.5.  This parameter does not identify the data file format.  See fFileVersionNumber.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {36\cell nFileType\cell }{\ul\cf11 short}{\v short}{\cell Numeric equivalent of file type.  1 = ABF file;  2 = Old FETCHEX file (FTCX);  3 = Old Clampex file (CLPX).  See sFileType.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {38\cell nMSBinFormat\cell }{\ul\cf11 short}{\v short}{\cell Storage method for real numbers in the header.  Also see nDataFormat.  0 = IEEE format;  1 = Microsoft Binary format (old files only).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ File_Structure}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ File Structure}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ File Structure;lDataSectionPtr;lTagSectionPtr;lNumTagEntries;lScopeConfigPtr;lNumScopes;lDACFilePtr;lDACFileNumEpisodes;lDeltaArrayPtr;lNumDeltas;lSynchArrayPtr;lSynchArraySize;nDataFormat;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ File Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(80 bytes)
\par Header entries describing the structure of the }{\ul\cf11 file}{\v File}{.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {40\cell lDataSectionPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of Data section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {44\cell lTagSectionPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of Tag section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {48\cell lNumTagEntries\cell }{\ul\cf11 long}{\v long}{\cell Number of Tag entries.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {52\cell lScopeConfigPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of the ABF Scope Config section.\line (was block number of start of Long Description section.)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {56\cell lNumScopes\cell }{\ul\cf11 long}{\v long}{\cell Number of ABFScopeConfig structures in the ABF Scope Config section.\line (was number of lines of Long Description.)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {60\cell lDACFilePtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of }{\ul\cf11 DAC}{\v DAC_D_A}{ file section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {64\cell lDACFileNumEpisodes\cell }{\ul\cf11 long}{\v long}{\cell Number of }{\ul\cf11 sweeps}{\v Sweep}{ in the DAC  file section.  Sweeps are not multiplexed.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {68\cell sUnused68\cell 4char\cell }\pard\plain \s19\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Unused.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard \sb120\widctlpar\intbl\adjustright {72\cell lDeltaArrayPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of Delta Array section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {76\cell lNumDeltas\cell }{\ul\cf11 long}{\v long}{\cell Number of entries in Delta Array section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {80\cell lVoiceTagPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of Voice Tag section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {84\cell lVoiceTagEntries\cell }{\ul\cf11 long}{\v long}{\cell Number of Voice Tag entries.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {88\cell lUnused88\cell }{\ul\cf11 long}{\v long}{\cell (was number of automatic entries in Notebook section)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {92\cell lSynchArrayPtr\cell }{\ul\cf11 long}{\v long}{\cell Block number of start of the Synch Array section.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {96\cell lSynchArraySize\cell }{\ul\cf11 long}{\v long}{\cell Number of pairs of entries in the Synch Array section.  If averaging is enabled, this includes the entry for the averaged }{\ul\cf11 sweep}{\v Sweep}{.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {100\cell nDataFormat\cell }{\ul\cf11 short}{\v short}{\cell Data representation.  0 = 2-byte integer;  1 = IEEE 4 byte }{\ul\cf11 float}{\v float}{.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {102\cell nSimultaneousScan\cell }{\ul\cf11 short}{\v short}{\cell ADC Channel Scanning Mode:  0=Multiplexed; 1=Simultaneous Scanning (currently unimplemented)\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {104\cell sUnused104\cell }\pard\plain \s19\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 16char\cell }\pard\plain \sb120\widctlpar\intbl\adjustright \f1\fs20\cgrid {Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Trial_Hierarchy_Information}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Trial Hierarchy Information}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Trial Hierarchy Information;nADCNumChannels;fADCSampleInterval;fADCSecondSampleInterval;fSynchTimeUnit;fSecondsPerRun;lNumSamplesPerEpisode;lPreTriggerSamples;lEpisodesPerRun;lRunsPerTrial;lNumberOfTrials;nAveragingMode;nUndoRunCount;nFirstEpisodeInRun;fTriggerThreshold;nTriggerSource;nTriggerAction;nTriggerPolarity;fScopeOutputInterval;fEpisodeStartToStart;fRunStartToStart;fTrialStartToStart;lAverageCount;lClockChange;nAutoTriggerStrategy}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Trial Hierarchy Information
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(80 bytes)
\par Header entries describing the }{\ul\cf11 trial}{\v Trial}{ }{\ul\cf11 hierarchy}{\v Hierarchy}{.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\b\fs20 Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 120\cell nADCNumChannels\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Number of analog input channels sampled.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 122\cell fADCSampleInterval\cell }{\ul\cf11 float}{\v float}{\fs20 \cell Interval between multiplexed }{\fs20\ul\cf11 A/D}{\v\fs20 ADC_A_D}{\fs20  samples (us).  In Clampex, this is also known as the first clock interval.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 126\cell fADCSecondSampleInterval\cell }{\ul\cf11 float}{\v float}{\fs20 \cell Second definition of the interval between multiplexed A/D samples  (us).  If this interval is zero, the first clock interval is used for the whole of each }{\fs20\ul\cf11 sweep}{\v\fs20 Sweep}{\fs20 .  If this interval is non-zero, the second clock interval starts at the sample number specified by lClockChange.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 130\cell fSynchTimeUnit\cell }{\ul\cf11 float}{\v float}{\fs20 \cell Time unit for start time in the Synch Array section: 0 = Value in sample intervals;  nn = Value in }{\fs20 {\field{\*\fldinst SYMBOL 109 \\f "Symbol" \\s 10}{\fldrslt\f3\fs20\'6d}}}{\fs20 s.  See notes below for the Synch Array section.  pCLAMP 6.0 and AxoTape 2.0 use value in sample intervals only.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 134\cell fSecondsPerRun\cell }{\ul\cf11 float}{\v float}{\fs20 \cell Requested acquisition length in seconds.  0 means use available disk space.  -1 means ignore this parameter and refer to lEpisodesPerRun.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 138\cell lNumSamplesPerEpisode\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell Number of multiplexed }{\fs20\ul\cf11 ADC}{\v\fs20 ADC_A_D}{\fs20  samples per }{\fs20\ul\cf11 sweep}{\v\fs20 Sweep}{\fs20  if nOperationMode is 2, 4, or 5.  Undefined if nOperationMode is 1 or 3.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 142\cell lPreTriggerSamples\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell Pre-trigger interval stored as number of multiplexed ADC samples (note that this is the underlying number of ADC samples, not the number of pre-trigger samples in the trigger channel).  FETCHEX uses the same value for the post-trigger interval.  Undefined if nOperationMode is 3 or 5.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 146\cell lEpisodesPerRun\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20  \cell Requested number of sweeps/}{\fs20\ul\cf11 run}{\v\fs20 Run}{\fs20 .  0=Run until terminated by user. If nOperationMode = 3 (}{\fs20\ul\cf11 gap free}{\v\fs20 Gap_Free}{\fs20 ), this parameter is 1 and the requested acquisition length is set in fSecondsPerRun.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 150\cell lRunsPerTrial\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell Requested number of runs/}{\fs20\ul\cf11 trial}{\v\fs20 Trial}{\fs20 .  0=Run until terminated by user. Runs are averaged.  If nOperationMode = 3 (gap free), the value of this parameter is 1.  See lAverageCount.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 154\cell lNumberOfTrials\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell Number of trials to be acquired.  Note, only one trial is contained in a data file.  This parameter is used for Clampex acquisition control.  -1 = continuous.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 158\cell nAveragingMode\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Data averaging strategy: 0 = No averaging; 1 = Average but don't save raw data; 2 = Average and save raw data.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 160\cell nUndoRunCount\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Frequency with which temporary undo file created during averaging is updated.  -1 = Disabled;  0 = after each pseudo-doubling;  N = after every N runs.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 162\cell nFirstEpisodeInRun\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell First }{\fs20\ul\cf11 sweep}{\v\fs20 Sweep}{\fs20  number (normally 1).\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 164\cell fTriggerThreshold\cell }{\ul\cf11 float}{\v float}{\fs20 \cell Trigger threshold value for Event or Oscilloscope mode (user units).\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 168\cell nTriggerSource\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Trigger source:  N (>=0) = Physical channel number selected for threshold detection;  -1 = external trigger;  -2 = keyboard;  -3 =  use start-to-start interval.
{\v0\par\v}If nOperationMode=3 (gap-free)  0= start immediately.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 170\cell nTriggerAction\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Trigger start strategy: 0 = start one }{\fs20\ul\cf11 sweep}{\v\fs20 Sweep}{\fs20 ;  1 = start one }{\fs20\ul\cf11 run}{\v\fs20 Run}{\fs20 ;  2 = start one }{\fs20\ul\cf11 trial}{\v\fs20 Trial}{\fs20 .\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 172\cell nTriggerPolarity\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell Trigger on:  0 = rising edge of waveform;  1 = falling edge.  The terms "rising" and "falling" refer to the direction of the data transitions on the screen during acquisition.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 174\cell fScopeOutputInterval\cell }{\fs20\ul\cf11 float}{\v\fs20 float}{\fs20 \cell Interval between digital output used for external oscilloscope, or equivalent, and the start of each }{\fs20\ul\cf11 sweep}{\v\fs20 Sweep}{\fs20  (ms)\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 178\cell fEpisodeStartToStart\cell }{\fs20\ul\cf11 float}{\v\fs20 float}{\fs20 \cell Time between start of sweeps (seconds).  Use when nTriggerSource = "start-to-start".\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 182\cell fRunStartToStart\cell }{\fs20\ul\cf11 float}{\v\fs20 float}{\fs20 \cell Time between start of runs (seconds).\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 186\cell fTrialStartToStart\cell }{\fs20\ul\cf11 float}{\v\fs20 float}{\fs20 \cell Time between trials (seconds).\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 190\cell lAverageCount\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell The actual number of runs contributing to each average.  See lEpisodesPerRun or lRunsPerTrial.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 194\cell lClockChange\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20 \cell The multiplexed ADC sample number after which the second sampling interval commences.  0 = lNumSamplesPerEpisode/2.  See fADCSecondSampleInterval.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 198\cell nAutoTriggerStrategy\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20 \cell 0 = Do not auto trigger;  1 = Autotrigger. \line (Only significant when nOperationMode == ABF_HIGHSPEEDOSC)\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Display_Parameters}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Display Parameters}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Display Parameters;nDrawingStrategy;nTiledDisplay;nEraseStrategy;nDataDisplayMode;lDisplayAverageUpdate;nChannelStatsStrategy;lCalculationPeriod;lSamplesPerTrace;lStartDisplayNum;lFinishDisplayNum;nMultiColor;nShowPNRawData;fStatisticsPeriod}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Display Parameters
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(44 bytes)
\par Header entries describing display options in effect during acquisition.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx990\clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx990\clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {200\cell nDrawingStrategy\cell }{\ul\cf11 short}{\v short}{\cell Strategy for the drawing of raw data:   0 = not at all;  1 = update immediately as data is acquired;  2 = update at the end of each }{\ul\cf11 sweep}{\v Sweep}{ or }{\ul\cf11 trace}{\v Trace}{;  3 = update at the end of each }{\ul\cf11 run}{\v Run}{;\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx990\clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {202\cell nTiledDisplay\cell }{\ul\cf11 short}{\v short}{\cell }{\ul\cf11 ADC}{\v ADC_A_D}{ channel display arrangement:  0 = Superimposed;  1 = Tiled.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {204\cell nEraseStrategy\cell }{\ul\cf11 short}{\v short}{\cell Automatically erase screen: 0 = not at all;  1 = before each sweep;  2 = before each run.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {206\cell nDataDisplayMode\cell }{\ul\cf11 short}{\v short}{\cell Data display mode: 0 = Points;  1 = Lines.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {208\cell lDisplayAverageUpdate\cell }{\ul\cf11 long}{\v long}{\cell Display averaged data:  -1 = at end of }{\ul\cf11 trial}{\v Trial}{;  0 = after each pseudo-doubling;  N = after N runs.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {212\cell nChannelStatsStrategy\cell }{\ul\cf11 short}{\v short}{\cell Show channel statistics in }{\ul\cf11 gap-free}{\v Gap_Free}{ mode: 0 = No;  1 = Yes.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {214\cell lCalculationPeriod\cell }{\ul\cf11 long}{\v long}{\cell [Superceded by fStatisticsPeriod]\line Length of the real-time statistics update period in samples.  Conventionally a multiple of 1024.  Default = 16384.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {218\cell lSamplesPerTrace\cell }{\ul\cf11 long}{\v long}{\cell Number of multiplexed ADC samples in displayed }{\ul\cf11 trace}{\v Trace}{.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {222\cell lStartDisplayNum\cell }{\ul\cf11 long}{\v long}{\cell Starting sample number for }{\ul\cf11 sweep}{\v Sweep}{ display:  N = starting sample number.  (Use N = 1 to start from the first sample.)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {226\cell lFinishDisplayNum\cell }{\ul\cf11 long}{\v long}{\cell Finishing sample number for sweep display:  0 = finish at end of sweep;  N = finishing sample number.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {230\cell nMultiColor\cell }{\ul\cf11 short}{\v short}{\cell Color control for multi-trace displays.  0 = single color for all traces;  1 = two or more colors for traces.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {232\cell nShowPNRawData\cell }{\ul\cf11 short}{\v short}{\cell 0 = display corrected data;  1 = display raw data.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {234\cell fStatisticsPeriod\cell }{\ul\cf11 float}{\v float}{\cell Length of the real-time statistics update period in seconds.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trrh264\trkeep \clvertalt\cltxlrtb \cellx990\clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {238\cell lStatisticsMeasurements\cell }{\ul\cf11 long}{\v long}{\cell Bit mask for statistics measurements to display:\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trgaph85\trrh264\trkeep \clvmgf\clvertalt\cltxlrtb \cellx990\clvmgf\clvertalt\cltxlrtb \cellx3870\clvmgf\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx7341\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {\cell \cell }{\ul\cf11 \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Above Threshold:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000001\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trgaph85\trrh264\trkeep \clvmrg\clvertalt\cltxlrtb \cellx990\clvmrg\clvertalt\cltxlrtb \cellx3870\clvmrg\clvertalt\cltxlrtb \cellx4950\clvertalt\cltxlrtb \cellx7341\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {\cell \cell }{\ul\cf11 \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Event Frequency:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000002\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell }{\ul\cf11 \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Mean Open Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000004\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell }{\ul\cf11 \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Mean Closed Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000008\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx990\clvertalt\cltxlrtb \cellx3870\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9900\pard \sb120\widctlpar\intbl\adjustright {238\cell nStatisticsSaveStrategy\cell }{\ul\cf11 short}{\v short}{\cell Strategy used to save statistics: No Auto Save = 0; Auto Save = 1\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Hardware_Information}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Hardware Information}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Hardware Information;fADCRange;fDACRange;lADCResolution;lDACResolution}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Hardware Information
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(16 bytes)
\par Description of hardware properties of digitiser used for acquisition.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {244\cell fADCRange\cell }{\ul\cf11 float}{\v float}{\cell }{\ul\cf11 ADC}{\v ADC_A_D}{ positive full-scale input in volts (e.g. 10.00V).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {248\cell fDACRange\cell }{\ul\cf11 float}{\v float}{\cell }{\ul\cf11 DAC}{\v DAC_D_A}{ positive full-scale range in volts.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {252\cell lADCResolution\cell }{\ul\cf11 long}{\v long}{\cell Number of }{\ul\cf11 ADC}{\v ADC_A_D}{ counts corresponding to the positive full-scale voltage in ADCRange (e.g. 2000, 2048, 32000 or 32768).\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {256\cell lDACResolution\cell }{\ul\cf11 long}{\v long}{\cell Number of DAC counts corresponding to the positive full-scale voltage in DACRange.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Environmental_information}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Environmental information}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Environmental information;nExperimentType;nAutosampleEnable;nAutosampleADCNum;nAutosampleInstrument;fAutosampleAdditGain;fAutosampleFilter;fAutosampleMembraneCap;nManualInfoStrategy;fCellID1;fCellID2;fCellID3;sCreatorInfo;sFileComment}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Environmental information
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(118 bytes)
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {260\cell nExperimentType\cell }{\ul\cf11 short}{\v short}{\cell Experiment type:  0 = Voltage Clamp;  1 = Current Clamp.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {262\cell nAutosampleEnable\cell }{\ul\cf11 short}{\v short}{\cell Enable storage of autosample information:  0 = Disabled;  1 = Automatic;  2 = Manual.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {264\cell nAutosampleADCNum\cell }{\ul\cf11 short}{\v short}{\cell Physical }{\ul\cf11 ADC}{\v ADC_A_D}{ channel number to which autosampled parameters apply.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {266\cell nAutosampleInstrument\cell }{\ul\cf11 short}{\v short}{\cell Autosample }{\ul\cf11 instrument}{\v Instrument}{:\line 0 = Unknown instrument\line 1 = Axopatch-1 with CV-4-1/100;\line 2 = Axopatch-1 with CV-4-0.1/100;\line 3 = Axopatch-1B(inv.) CV-4-1/100;\line 4 = Axopatch-1B(inv) CV-4-0.1/100;\line 5 = Axopatch 200 with CV 201;\line 6 = Axopatch 200 with CV 202;\line 7 = GeneClamp.\line 8 = Dagan 3900\line 9 = Dagan 3900A\line 10 = Dagan CA-1  Im=0.1\line 11 = Dagan CA-1  Im=1.0\line 12 = Dagan CA-1  Im=10\line 13 = Warner OC-725\line 14 = Warner OC-725C\line 15 = AxoPatch 200B\line 16 = Dagan PC-ONE Im=0.1\line 17 = Dagan PC-ONE Im=1.0\line 18 = Dagan PC-ONE Im=10\line 19 = Dagan PC-ONE Im=100\line 20 = Warner BC-525C\line 21 = Warner PC-505\line 22 = Warner PC-501\line 23 = Dagan CA-1 Im=0.05
{\v0\par\v}(IHS-1 telegraphs are not supported.)   Note, for most programs this is an information-only field.  For example, in Clampex the autosample instrument is chosen as a configuration item and copied into this field.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {268\cell fAutosampleAdditGain\cell }{\ul\cf11 float}{\v float}{\cell Additional gain multiplier of Instrument connected to nAutosampleADCNum.  (Optionally autosampled by some acquisition programs.)   (Default = 1)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {272\cell fAutosampleFilter\cell }{\ul\cf11 float}{\v float}{\cell Lowpass filter cutoff frequency of Instrument connected to nAutosampleADCNum.  (Optionally autosampled by some acquisition programs.)   (Default = 100000)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {276\cell fAutosampleMembraneCap\cell }{\ul\cf11 float}{\v float}{\cell Patch-clamp membrane capacitance compensation.  (Optionally autosampled by some acquisition programs.)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {280\cell nManualInfoStrategy\cell }{\ul\cf11 short}{\v short}{\cell Strategy for writing the manually entered information:  0 = Do not write;  1 = Write each }{\ul\cf11 trial}{\v Trial}{;  2 = Prompt each trial..\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {282\cell fCellID1\cell }{\ul\cf11 float}{\v float}{\cell Numeric identifier #1, e.g. cell identifier.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {286\cell fCellID2\cell }{\ul\cf11 float}{\v float}{\cell Numeric identifier #2, e.g. temperature in \'b0C.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {290\cell fCellID3\cell }{\ul\cf11 float}{\v float}{\cell Numeric identifier #3.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {294\cell sCreatorInfo\cell 16char\cell Name and version of program used to create the file.  For example, "AxoTape 2.0" or "Clampex 6.0".\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {310\cell sFileComment\cell 56char\cell 56 byte ASCII comment string.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {366\cell sUnused366\cell 12char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Multi_channel_information}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Multi-channel information}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Multi-channel information;nADCPtoLChannelMap;nADCSamplingSeq;sADCChannelName;sADCUnits;fADCProgrammableGain;fADCDisplayAmplification;fADCDisplayOffset;fInstrumentScaleFactor;fInstrumentOffset;fSignalGain;fSignalOffset;fSignalLowpassFilter;fSignalHighpassFilter;sDACChannelName;sDACChannelUnits;fDACScaleFactor;fDACHoldingLevel;nSignalType}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Multi-channel information
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {((160 + 384 + 488 + 12)=1044  bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {378\cell nADCPtoLChannelMap(0-15)\cell }{\ul\cf11 short}{\v short}{\cell }{\ul\cf11 ADC}{\v ADC_A_D}{ physical-to-logical channel map.  The entries are in the physical order 0, 1, 2, ... 14, 15.  If there are fewer than 16 logical channels in the system, the array is padded with -1.  All channels supported by the hardware are present, even if only a subset is used.  For example, for the TL-2 the entries would be 7, 6, 5, 4, 3, 2, 1, 0, -1 ... -1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {410\cell nADCSamplingSeq(0-15)\cell }{\ul\cf11 short}{\v short}{\cell ADC channel sampling }{\ul\cf11 sequence}{\v Sequence}{.  This is the order in which the physical ADC channels are sampled.  If fewer than the maximum number of channels are sampled, pad with -1.  For example, if two channels are sampled on the TL-2, this array will contain 6, 7, -1 ... -1.  If two channels are sampled on the TL-1, this array will contain 14, 15, -1 ... -1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {442\cell sADCChannelName(0-15)\cell 10}{\ul\cf11 char}{\v nn_char}{\cell ADC channel name in physical channel number order.  Default = spaces.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {602\cell sADCUnits(0-15)\cell 8}{\ul\cf11 char}{\v nn_char}{\cell The user units for ADC channels in physical channel number order.  Default = spaces.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {730\cell fADCProgrammableGain(0-15)\cell }{\ul\cf11 float}{\v float}{\cell ADC programmable gain in physical channel number order (dimensionless).  Default = 1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {794\cell fADCDisplayAmplification(0-15)\cell }{\ul\cf11 float}{\v float}{\cell ADC channel display amplification in physical channel number order (dimensionless.)   Default = 1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {858\cell fADCDisplayOffset(0-15)\cell }{\ul\cf11 float}{\v float}{\cell ADC channel display offset in physical channel number order (user units).  Default = 0.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {922\cell fInstrumentScaleFactor(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Instrument scale factor in physical ADC channel number order (Volts at ADC / user unit).  (Programs would normally display this information to the user as user units / volt at ADC).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {986\cell fInstrumentOffset(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Instrument offset in physical ADC channel number order (user units corresponding to 0 V at the ADC).  Default is zero.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1050\cell fSignalGain(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Signal conditioner gain in physical ADC channel number order (dimensionless).  Default = 1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1114\cell fSignalOffset(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Signal conditioner offset in physical ADC channel number order (user units).  Default = 0.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1178\cell fSignalLowpassFilter(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Signal-conditioner lowpass filter corner frequency in physical ADC channel number order (Hz).  100000 means lowpass filter is bypassed (i.e. wideband).  Default = 100000.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1242\cell fSignalHighpassFilter(0-15)\cell }{\ul\cf11 float}{\v float}{\cell Signal-conditioner highpass filter corner frequency in physical ADC channel number order (Hz).  0 means highpass filter is bypassed (i.e. DC coupled).  -1 means inputs are grounded.  Default = 0.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1306\cell sDACChannelName(0-3)\cell 10}{\ul\cf11 char}{\v nn_char}{\cell }{\ul\cf11 DAC}{\v DAC_D_A}{ channel name.  Default = spaces.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1346\cell sDACChannelUnits(0-3)\cell 8}{\ul\cf11 char}{\v nn_char}{\cell The user units for this DAC channel.  Default = spaces.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1378\cell fDACScaleFactor(0-3)\cell }{\ul\cf11 float}{\v float}{\cell DAC channel gain (user units / V at DAC).  Default = 1\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1394\cell fDACHoldingLevel(0-3)\cell }{\ul\cf11 float}{\v float}{\cell DAC channel holding level (user units).  Default = 0.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1410\cell nSignalType\cell }{\ul\cf11 short}{\v short}{\cell Type of }{\ul\cf11 signal conditioner}{\v Signal_Conditioner}{ that was used.  0 = None;  1 = CyberAmp 320/380.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1412\cell sUnused1412\cell 10char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Synchronous_timer_outputs}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Synchronous timer outputs}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Synchronous timer outputs;nOUTEnable;nSampleNumberOUT1;nSampleNumberOUT2;nFirstEpisodeOUT;nLastEpisodeOUT;nPulseSamplesOUT1;nPulseSamplesOUT2;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Synchronous timer outputs
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(14 bytes)
\par Synchronous timer outputs were dropped from pCLAMP version 6.  These parameters have been kept in the ABF 1.0 specification for compatibility when reading old data files.  New programs should write zeros to all of the parameters in this group.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1422\cell nOUTEnable\cell }{\ul\cf11 short}{\v short}{\cell Enable synchronous timer outputs:  0 = No;  1 = Yes.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1424\cell nSampleNumberOUT1\cell }{\ul\cf11 short}{\v short}{\cell Sample number for pulse on synchronous timer OUT #1.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1426\cell nSampleNumberOUT2\cell }{\ul\cf11 short}{\v short}{\cell Sample number for pulse on synchronous timer OUT #2.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1428\cell nFirstEpisodeOUT\cell }{\ul\cf11 short}{\v short}{\cell First }{\ul\cf11 sweep}{\v Sweep}{ at which synchronous timer OUT #1 and #2 fire.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1430\cell nLastEpisodeOUT\cell }{\ul\cf11 short}{\v short}{\cell Last sweep at which synchronous timer OUT #1 and #2 fire.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1432\cell nPulseSamplesOUT1\cell }{\ul\cf11 short}{\v short}{\cell Duration and polarity of pulse on synchronous timer OUT #1 (}{\ul\cf11 DAC}{\v DAC_D_A}{ samples).\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1434\cell nPulseSamplesOUT2\cell }{\ul\cf11 short}{\v short}{\cell Duration and polarity of pulse on synchronous timer OUT #2 (DAC samples).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Epoch_Waveform_and_Pulses}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Epoch Waveform and Pulses}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Epoch Waveform and Pulses;nDigitalEnable;nWaveformSource;nActiveDACChannel;nInterEpisodeLevel;nEpochType;fEpochInitLevel;fEpochLevelInc;nEpochInitDuration;nEpochDurationInc;nDigitalHolding;nDigitalInterEpisode;nDigitalValue}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Epoch Waveform and Pulses
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(184 bytes)
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1436\cell nDigitalEnable\cell }{\ul\cf11 short}{\v short}{\cell Enable digital outputs:  0 = No;  1 = Yes.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1438\cell nWaveformSource\cell }{\ul\cf11 short}{\v short}{\cell Analog waveform source:  0 = Disable;  1 = Generate waveform from epoch definitions;  2 = Generate waveform from a }{\ul\cf11 DAC}{\v DAC_D_A}{ file.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1440\cell nActiveDACChannel\cell }{\ul\cf11 short}{\v short}{\cell Active }{\ul\cf11 DAC}{\v DAC_D_A}{ channel, i.e. the one used for waveform generation.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1442\cell nInterEpisodeLevel\cell }{\ul\cf11 short}{\v short}{\cell Inter-}{\ul\cf11 sweep}{\v Sweep}{ holding level:  0 = Use holding level;  1 = Use last epoch amplitude.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1444\cell nEpochType(0-9)\cell }{\ul\cf11 short}{\v short}{\cell Epoch type:  0 = Disabled;  1 = Step;  2 = Ramp\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1464\cell fEpochInitLevel(0-9)\cell }{\ul\cf11 float}{\v float}{\cell Epoch initial level (user units)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1504\cell fEpochLevelInc(0-9)\cell }{\ul\cf11 float}{\v float}{\cell Epoch level increment (user units)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1544\cell nEpochInitDuration(0-9)\cell }{\ul\cf11 short}{\v short}{\cell Epoch initial duration (in }{\ul\cf11 sequence}{\v Sequence}{ counts).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1564\cell nEpochDurationInc(0-9)\cell }{\ul\cf11 short}{\v short}{\cell Epoch duration increment (in sequence counts)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1584\cell nDigitalHolding\cell }{\ul\cf11 short}{\v short}{\cell Holding value for digital output.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1586\cell nDigitalInterEpisode\cell }{\ul\cf11 short}{\v short}{\cell Inter-}{\ul\cf11 sweep}{\v Sweep}{ digital holding value:  0 = Use holding value;  1 = Use last epoch value.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1588\cell nDigitalValue(0-9)\cell }{\ul\cf11 short}{\v short}{\cell Epoch value for digital output (0..15).\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1608\cell sUnavailable1608\line (was fWaveformOffset)\cell 4}{\ul\cf11 char}{\v nn_char}{\cell This parameter was used by CLAMPFIT 6.0, }{\b do not reuse}{.
{\v0\par\v}}{\fs16 Offset (in active DAC user units) in }{\fs16\ul\cf11 instrument}{\v\fs16 Instrument}{\fs16  command pathway, usually due to a non-zero holding potential or current.}{\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1612\cell sUnused1612\cell 8char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ DAC_Output_File}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ DAC Output File}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ DAC Output File;fDACFileScale;fDACFileOffset;nDACFileEpisodeNum;nDACFileADCNum;sDACFileName;sDACFilePath;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ DAC Output File
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(98 bytes)
\par Note that }{\ul\cf11 DAC}{\v DAC_D_A}{ output status is controlled by nWaveformSource.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1620\cell fDACFileScale\cell }{\ul\cf11 float}{\v float}{\cell Scaling factor to apply to DACfile contents.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1624\cell fDACFileOffset\cell }{\ul\cf11 float}{\v float}{\cell Offset (in user units) to apply to DACfile contents.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1628\cell sUnused1628\cell 2char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1630\cell nDACFileEpisodeNum\cell }{\ul\cf11 short}{\v short}{\cell Sweep (or column) number to replay from waveform file:  -1 = all }{\v sweepSweeps }{except the first (which is skipped), repeating last if necessary;  0 = all sweeps;  N = sweep number.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1632\cell nDACFileADCNum\cell }{\ul\cf11 short}{\v short}{\cell Logical }{\ul\cf11 ADC}{\v ADC_A_D}{ channel number to replay from waveform file.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1634\cell sDACFileName\cell 12}{\ul\cf11 char}{\v nn_char}{\cell Name of DAC file located in data directory.  Must be ABF or ATF format.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1646\cell sDACFilePath\cell 60}{\ul\cf11 char}{\v nn_char}{\cell Drive and directory for sDACFileName.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1706\cell sUnused1706\cell 12char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Conditioning_pulse_train}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Conditioning pulse train}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Conditioning pulse train;nConditEnable;nConditChannel;lConditNumPulses;fBaselineDuration;fBaselineLevel;fStepDuration;fStepLevel;fPostTrainPeriod;fPostTrainLevel;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Conditioning pulse train
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(44 bytes)
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1718\cell nConditEnable\cell }{\ul\cf11 short}{\v short}{\cell Conditioning pulse train activation status:  0  = Disable;  1 = Enable\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1720\cell nConditChannel\cell }{\ul\cf11 short}{\v short}{\cell }{\ul\cf11 DAC}{\v DAC_D_A}{ channel used for conditioning pulses.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1722\cell lConditNumPulses\cell }{\ul\cf11 long}{\v long}{\cell Number of pulses in conditioning pulse train\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1726\cell fBaselineDuration\cell }{\ul\cf11 float}{\v float}{\cell A single pulse in the conditioning train consists of a baseline followed by a step.  This parameter is the baseline duration in ms\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1730\cell fBaselineLevel\cell }{\ul\cf11 float}{\v float}{\cell Baseline level (user units)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1734\cell fStepDuration\cell }{\ul\cf11 float}{\v float}{\cell Step duration (ms)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1738\cell fStepLevel\cell }{\ul\cf11 float}{\v float}{\cell Step level (user units)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1742\cell fPostTrainPeriod\cell }{\ul\cf11 float}{\v float}{\cell At the end of the conditioning train there is a post-train steady-state output.  This parameter is the post-train duration in ms.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1746\cell fPostTrainLevel\cell }{\ul\cf11 float}{\v float}{\cell Post-train level (user units)\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1750\cell sUnused1750\cell 12}{\ul\cf11 char}{\v nn_char}{\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Variable_Parameter_User_List}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Variable Parameter User List}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Variable Parameter User List;nParamToVary;sParamValueList}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Variable Parameter User List
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(82 bytes)
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1762\cell nParamToVary\cell }{\ul\cf11 short}{\v short}{\cell Holds the index of the parameter that varies from }{\ul\cf11 sweep}{\v Sweep}{ to sweep in one }{\ul\cf11 run}{\v Run}{.\line CONDITNUMPULSES=0\line CONDITBASELINEDURATION=1\line CONDITBASELINELEVEL=2\line CONDITSTEPDURATION=3\line CONDITSTEPLEVEL=4\line CONDITPOSTTRAINDURATION=5\line CONDITPOSTTRAINLEVEL=6\line EPISODESTARTTOSTART =7\line INACTIVEHOLDING=8\line DIGITALINTEREPISODE=9\line PNNUMPULSES=10\line PARALLELVALUE(0-9)=11-20\line EPOCHINITLEVEL(0-9)=21-30\line EPOCHINITDURATION(0-9)=31-40\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1764\cell sParamValueList\cell 80}{\ul\cf11 char}{\v nn_char}{\cell List of comma-separated values.  If the number of entries in the list is fewer than the requested number of }{\ul\cf11 sweeps}{\v Sweep}{ , the last list value is re-used.  If there are more values in the list, the excess list values are ignored.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell See also nListEnable in Group #16.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Autopeak_measurement}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Autopeak measurement}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Autopeak measurement;nAutopeakEnable;nAutopeakPolarity;nAutopeakADCNum;nAutopeakSearchMode;lAutopeakStart;lAutopeakEnd;nAutopeakSmoothing;nAutopeakBaseline;nAutopeakAverage;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ statistics measurement
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(36 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx4542\clvertalt\cltxlrtb \cellx10632\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3544\clvertalt\cltxlrtb \cellx4542\clvertalt\cltxlrtb \cellx10632\pard \sb120\widctlpar\intbl\adjustright {1844\cell nAutopeakEnable\cell }{\ul\cf11 short}{\v short}{\cell Autopeak activation status:  0  = Disabled;  1 = Enabled.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1846\cell nAutopeakPolarity\cell }{\ul\cf11 short}{\v short}{\cell -1 = search for negative peaks;  0 = search for absolute peak;  1 = search for positive peaks.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1848\cell nAutopeakADCNum\cell }{\ul\cf11 short}{\v short}{\cell Physical }{\ul\cf11 ADC}{\v ADC_A_D}{ channel number to measure.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1850\cell nAutopeakSearchMode\cell }{\ul\cf11 short}{\v short}{\cell Search mode:  0-9 = epoch A-J;  -1 = All;  -2 = Use specified region.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1852\cell lAutopeakStart\cell }{\ul\cf11 long}{\v long}{\cell Start of specified statistics region.  Only valid if nAutopeakSearchMode = -2.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1856\cell lAutopeakEnd\cell }{\ul\cf11 long}{\v long}{\cell End of specified statistics region.  Only valid if nAutopeakSearchMode = -2.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1860\cell nAutopeakSmoothing\cell }{\ul\cf11 short}{\v short}{\cell Number of samples averaged in boxcar smoothing window when looking for a peak.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1862\cell nAutopeakBaseline\cell }{\ul\cf11 short}{\v short}{\cell Baseline for statistics measurements:  -2 = None; -1 = Average the first (lNumSamplesPerEpisode/64) samples;  0-9 = epoch A-J\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1864\cell nAutopeakAverage\cell }{\ul\cf11 short}{\v short}{\cell 0 = search average and data;  1 = search average only.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1866\cell sUnavailable1866\cell 2}{\ul\cf11 char}{\v nn_char}{\cell [Superceded by nStatisticsSaveStrategy] nAutopeakSaveStrategy\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1868\cell lAutopeakBaselineStart\cell }{\ul\cf11 long}{\v long}{\cell Start of baseline used in statistics measurements.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1872\cell lAutopeakBaselineEnd\cell }{\ul\cf11 long}{\v long}{\cell End of baseline used in statistics measurements.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1876\cell lAutopeakMeasurements\cell }{\ul\cf11 long}{\v long}{\ul\cf11 \cell }{Bit mask indicating which statistics measurements to perform.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trrh340\trkeep \clvmgf\clvertalt\cltxlrtb \cellx934\clvmgf\clvertalt\cltxlrtb \cellx3544\clvmgf\clvertalt\cltxlrtb \cellx4542\clvertalt\cltxlrtb \cellx6237\clvertalt\cltxlrtb \cellx7655\clvertalt\cltxlrtb \cellx9498\clvertalt\cltxlrtb \cellx10632\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Peak:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000001\cell }\pard\plain \s19\qr\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Peak time:  \cell }\pard\plain \sb120\widctlpar\intbl\adjustright \f1\fs20\cgrid {0x00000002\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trrh340\trkeep \clvmrg\clvertalt\cltxlrtb \cellx934\clvmrg\clvertalt\cltxlrtb \cellx3544\clvmrg\clvertalt\cltxlrtb \cellx4542\clvertalt\cltxlrtb \cellx6237\clvertalt\cltxlrtb \cellx7655\clvertalt\cltxlrtb \cellx9498\clvertalt\cltxlrtb \cellx10632\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Antipeak:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000004\cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Antipeaktime:  \cell }\pard\plain \s19\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 0x00000008\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Mean: \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000010\cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Standard Deviation:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000020\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Integral:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000040\cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Left Slope:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000080\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Left Slope Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000100\cell }\pard \qr\ri-381\sb120\widctlpar\intbl\adjustright {Right Slope:  \cell }\pard \ri-381\sb120\widctlpar\intbl\adjustright {0x00000200\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Right Slope Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000400\cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Rise Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00000800\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Decay Time:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00001000\cell }\pard\plain \s19\qr\sb120\widctlpar\intbl\adjustright \f9\fs20\cgrid {\f1 Half Width:  \cell }\pard\plain \sb120\widctlpar\intbl\adjustright \f1\fs20\cgrid {0x00002000\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trrh340\trkeep \clvmrg\clvertalt\cltxlrtb \cellx934\clvmrg\clvertalt\cltxlrtb \cellx3544\clvmrg\clvertalt\cltxlrtb \cellx4542\clvertalt\cltxlrtb \cellx6237\clvertalt\cltxlrtb \cellx7655\clvertalt\cltxlrtb \cellx9498\clvertalt\cltxlrtb \cellx10632\pard \sb120\widctlpar\intbl\adjustright {\cell \cell \cell }\pard \qr\sb120\widctlpar\intbl\adjustright {Baseline:  \cell }\pard \sb120\widctlpar\intbl\adjustright {0x00004000\cell }\pard \qr\ri-381\sb120\widctlpar\intbl\adjustright {\cell }\pard \ri-381\sb120\widctlpar\intbl\adjustright {\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Channel_Arithmetic}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Channel Arithmetic}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Channel Arithmetic;nArithmeticEnable;fArithmeticUpperLimit;fArithmeticLowerLimit;nArithmeticADCNumA;nArithmeticADCNumB;fArithmeticK1;fArithmeticK2;fArithmeticK3;fArithmeticK4;sArithmeticOperator;sArithmeticUnits;fArithmeticK5;fArithmeticK6;nArithmeticExpression;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Channel Arithmetic
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(52 bytes)
\par Several standard arithmetic expressions are supported:
\par Expression #0 (general purpose)\line Result = (K1*A + K2) <op> (K3*B + K4)
\par Expression #1 (ratio dyes)\line Result = (K1*R + K2) <op> (K3*R + K4)\line where\line R = (A + K5)/(B + K6)
\par In both cases:\line A and B are }{\ul\cf11 ADC}{\v ADC_A_D}{ channel numbers.  A = B is allowed.\line K1 .. K6 are constants.\line <op> is an arithmetic operator.\line 
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1880\cell nArithmeticEnable\cell }{\ul\cf11 short}{\v short}{\cell Arithmetic activation status:  0  = Disable;  1 = Enable\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1882\cell fArithmeticUpperLimit\cell }{\ul\cf11 float}{\v float}{\cell Display upper limit for arithmetic Results channel.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1886\cell fArithmeticLowerLimit\cell }{\ul\cf11 float}{\v float}{\cell Display lower limit for arithmetic Results channel.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1890\cell nArithmeticADCNumA\cell }{\ul\cf11 short}{\v short}{\cell Physical ADC channel number used for A.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1892\cell nArithmeticADCNumB\cell }{\ul\cf11 short}{\v short}{\cell Physical ADC channel number used for B.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1894\cell fArithmeticK1\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K1\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1898\cell fArithmeticK2\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K2\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1902\cell fArithmeticK3\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K3\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1906\cell fArithmeticK4\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K4\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1910\cell sArithmeticOperator\cell 2}{\ul\cf11 char}{\v nn_char}{\cell Arithmetic operator:  "+ ", "- ", "* " or "/ ".\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1912\cell SArithmeticUnits\cell 8char\cell Units for Results channel.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1920\cell fArithmeticK5\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K5\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1924\cell fArithmeticK6\cell }{\ul\cf11 float}{\v float}{\cell Numeric constant K6\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1928\cell NArithmeticExpression\cell }{\ul\cf11 short}{\v short}{\cell The expression to evaluate:  N = Expression #N.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1930\cell sUnused1930\cell 2char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ On_line_Subtraction}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ On-line Subtraction}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ On-line Subtraction;nPNEnable;nPNPosition;nPNPolarity;nPNNumPulses;nPNADCNum;fPNHoldingLevel;fPNSettlingTime;fPNInterpulse;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ On-line Subtraction
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(34 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923{\b Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1932\cell nPNEnable\cell }{\ul\cf11 short}{\v short}{\cell P/N activation status:  0  = Disable;  1 = Enable\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1934\cell nPNPosition\cell }{\ul\cf11 short}{\v short}{\cell P/N subpulse execution:  0 = Before waveform;  1 = After waveform.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1936\cell nPNPolarity\cell }{\ul\cf11 short}{\v short}{\cell -1 = opposite polarity to the waveform;  1 = same polarity as the waveform.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1938\cell nPNNumPulses\cell }{\ul\cf11 short}{\v short}{\cell Number of P/N subpulses.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1940\cell nPNADCNum\cell }{\ul\cf11 short}{\v short}{\cell Physical }{\ul\cf11 ADC}{\v ADC_A_D}{ channel number for P/N subtraction.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1942\cell fPNHoldingLevel\cell }{\ul\cf11 float}{\v float}{\cell Subpulse holding level.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1946\cell fPNSettlingTime\cell }{\ul\cf11 float}{\v float}{\cell Settling time at subpulse holding level (ms).  Wait this interval after changing to subpulse holding level before starting subpulses;  wait this interval after returning to normal holding level before starting epochs.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1950\cell fPNInterpulse\cell }{\ul\cf11 float}{\v float}{\cell Timing interval between the start of one subpulse and the start of the next (ms).\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1954\cell sUnused1954\cell 12}{\ul\cf11 char}{\v nn_char}{\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ Unused_space_at_end_of_header_block}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ Unused space at end of header block}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ Unused space at end of header block;nListEnable;nBellEnable(0-1);nBellLocation(0-1);nBellRepetitions(0-1);nLevelHysteresis;lTimeHysteresis;nAllowExternalTags;}}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ Unused space at end of header block
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(82 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {1966\cell nListEnable\cell }{\ul\cf11 short}{\v short}{\cell Parameter list activation status:  0 = Disable;  1 = Enable\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1968\cell nBellEnable(0-1)\cell }{\ul\cf11 short}{\v short}{\cell Auditory tone activation status:  0 = Disable;  1 = Enable\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1972\cell nBellLocation(0-1)\cell }{\ul\cf11 short}{\v short}{\cell Location of bell relative to }{\ul\cf11 trial}{\v Trial}{: 0 = Before;  1 = After\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1976\cell nBellRepetitions(0-1)\cell }{\ul\cf11 short}{\v short}{\cell Number of sounds to produce.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1980\cell nLevelHysteresis\cell }{\ul\cf11 short}{\v short}{\cell Amount of level hysteresis to use when detecting events. This is the amount that the data has to go past the trigger level before it is considered triggered. Re-arming of the trigger level is always done at the actual nominated trigger level.  (See fTriggerThreshold)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1982\cell lTimeHysteresis\cell }{\ul\cf11 long}{\v long}{\cell Amount of time hysteresis to use when detecting events. This is the number of samples that have to be blow the trigger point before the trigger is said to be rearmed.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1986\cell nAllowExternalTags\cell }{\ul\cf11 short}{\v short}{\cell 0 = Do not scan for external tags during acquisition. 1 = Scan for external tags.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {1988\cell nLowpassFilterType(0-15)\cell char\cell Type of Low Pass filter for each }{\ul\cf11 ADC}{\v ADC_A_D}{ channel: 0 = None; 1 = External; 2 = Simple RC; 3 = Bessell; 4 = Butterworth.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2004\cell nHighpassFilterType(0-15)\cell char\cell Type of High Pass filter for each ADC channel: 0 = None; 1 = External; 2 = Simple RC; 3 = Bessell; 4 = Butterworth.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2020\cell nAverageAlgorithm\cell }{\ul\cf11 short}{\v short}{\cell Algorithm used for calculating averages: 0 = Cumulative Averaging; 1 = Most Recent Averaging (uses fAverageWeighting below)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2022\cell fAverageWeighting\cell }{\ul\cf11 float}{\v float}{\cell Weighting Factor for Most Recent Averaging.  This is the proportion of the incoming }{\ul\cf11 sweep}{\v Sweep}{ to include in the average.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2026\cell nUndoPromptStrategy\cell }{\ul\cf11 short}{\v short}{\cell Strategy for Prompting to create an Undo file:   0 = On Abort;  1 = Always;\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2028\cell nTrialTriggerSource\cell }{\ul\cf11 short}{\v short}{\cell Trigger source for start }{\ul\cf11 trial}{\v Trial}{: -3 = Spacebar; -2 = External Trigger; -1 = None\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2030\cell nStatisticsDisplayStrategy\cell }{\ul\cf11 short}{\v short}{\cell Strategy for displaying statistics: 0 = Display Statistics; 1 = Do Not display Statistics\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9923\pard \sb120\widctlpar\intbl\adjustright {2032\cell sUnused2032\cell 16char\cell Unused.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {\ul TOTAL  2048 bytes
\par }\pard\plain \s1\sb60\sa120\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ The_ABF_Scope_Config_Section}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ The ABF Scope Config Section}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ The ABF Scope Config Section;ABFLogFont;ABFSignal;ABFScopeConfig }}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Scope Config Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {If present, the ABF Scope Config section will contain one or more ABFScopeConfig structures describing the attributes of the scope windows used for data display during the data acquisition.
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFScopeConfig Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {Each ABFScopeConfig structure contains configuration information that describes the setup of a scope window. This structure in turn contains a structure (ABFLogFont) to define the font properties used to draw textual items such as tic labels, and an array of structures (of type ABFSignal), one for each }{\ul\cf11 ADC}{\v ADC_A_D}{ channel being acquired.
{\v0\par\v}}\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx5103\clvertalt\cltxlrtb \cellx8789\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx5103\clvertalt\cltxlrtb \cellx8789\pard \sb120\widctlpar\intbl\adjustright {0\cell dwFlags\cell }{\ul\cf11 DWORD}{\v DWORD}{ \cell Flags that are meaningful to the scope.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {4\cell rgbColor[ABF_SCOPECOLORS]\cell DWORD\cell Colors for the components of the scope.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {44\cell fDisplayStart\cell }{\ul\cf11 float}{\v float}{\cell Start of the display area in ms.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {48\cell fDisplayEnd\cell float\cell End of the display area in ms.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {52\cell wScopeMode\cell }{\ul\cf11 WORD}{\v WORD}{\cell The display mode: 0=sweeps; 1=continuous.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {54\cell bMaximized\cell char\cell TRUE = Scope parent is maximized.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {55\cell bMinimized\cell char\cell TRUE = Scope parent is minimized.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {56\cell xLeft\cell }{\ul\cf11 short}{\v short}{\cell Coordinate of the left edge.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {58\cell yTop\cell }{\ul\cf11 short}{\v short}{\cell Coordinate of the top edge.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {60\cell xRight\cell }{\ul\cf11 short}{\v short}{\cell Coordinate of the right edge.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {62\cell yBottom\cell }{\ul\cf11 short}{\v short}{\cell Coordinate of the bottom edge.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {64\cell LogFont\cell ABFLogFont\cell Description of current font.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {104\cell TraceList[ABF_ADCCOUNT]\cell ABFSignal\cell List of traces in current use - see nADCNumChannels in the ABFFileHeader for the number of channels actually used.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {648\cell nYAxisWidth\cell }{\ul\cf11 short}{\v short}{\cell Width of the YAxis region.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {650\cell nTraceCount\cell }{\ul\cf11 short}{\v short}{\cell Number of traces described in TraceList. (this should always match nADCNumChannels in the ABFFileHeader)\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {652\cell nEraseStrategy\cell }{\ul\cf11 short\cell }{Erase strategy: 0=Erase before each sweep; 1=Erase before each run; 2=Erase before each trial; 3=Do not erase\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx5103\clvertalt\cltxlrtb \cellx8789\pard \sb120\widctlpar\intbl\adjustright {654\cell nDockState\cell }{\ul\cf11 short}{\v short}{\cell Docking state: 0=Not docked; 1=Top; 2=Left; 3=Right; 4=Bottom.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {\ul TOTAL  656 bytes
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFLogFont Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {The ABFLogFont structure is a subset of the Windows LogFont structure, containing information to describe the characteristics of the font to be used in the Scope window.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {0\cell nHeight\cell }{\ul\cf11 short}{\v short}{\cell N.B. Height of the font in *points*.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {2\cell nWeight\cell }{\ul\cf11 short}{\v short}{\cell MSWindows font weight value.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {4\cell cPitchAndFamily\cell char\cell MSWindows pitch and family mask.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {5\cell Unused[3]\cell 3char\cell Unused space to maintain 4-byte packing.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {8\cell szFaceName[ABF_FACESIZE]\cell char\cell Face name of the font.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {\ul TOTAL  40 bytes
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {
\par The ABFSignal Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {The ABFSignal structure describes the characteristics of a single data trace on the screen, corresponding to a particular acquired signal.
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {0\cell szName[ABF_ADCNAMELEN+2]\cell }{\ul\cf11 char}{\cell ABF name length + '\\0' + 1 for alignment.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {12\cell nMxOffset\cell }{\ul\cf11 short}{\v short}{\cell Offset of the signal in the sampling sequence.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {14\cell RgbColor\cell }{\ul\cf11 DWORD}{\v DWORD}{ \cell Pen color used to draw trace.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {18\cell nPenWidth\cell char\cell Pen width in pixels.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {19\cell bDrawPoints\cell char\cell TRUE = Draw disconnected points.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {20\cell bHidden\cell char\cell TRUE = Hide the trace.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {21\cell bFloatData\cell char\cell TRUE = Floating point pseudo channel.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {22\cell fVertProportion\cell float\cell Relative proportion of the client are to use.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {26\cell fDisplayGain\cell char\cell Display gain of trace in UserUnits.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3931\clvertalt\cltxlrtb \cellx4929\clvertalt\cltxlrtb \cellx9072\pard \sb120\widctlpar\intbl\adjustright {30\cell fDisplayOffset\cell char\cell Display offset of trace in UserUnits.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\adjustright {\ul TOTAL  34 bytes
\par }\pard\plain \s1\sb60\sa120\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ The_ABF_Data_Section}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ The ABF Data Section}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ The ABF Data Section}}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Data Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {Acquired data samples are stored as multiplexed two-byte binary integers.  A special four-byte floating point version is used by some analysis programs for storage of analysis results  (see }{\uldb\cf11 nDataFormat}{\v File_Structure}{ in the file header section).  If the data file contains multiple }{\ul\cf11 sweeps}{\v Sweep}{ or segments of data, these are stored end for end without a gap.  That is, no parameters are stored between sweeps of the data; all parameters are stored in the header or in the specialized sections described below.  There is only one data section.
{\v0\par\v}}\pard\plain \s1\sb60\sa120\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ The_ABF_Synch_Section}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ The ABF Synch Section}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ The ABF Synch Section;ABFSynch }}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Synch Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {The ABF Synch array is an important array that stores the start time and length of each portion of the data if the data are not part of a continuous }{\ul\cf11 gap-free}{\v Gap_Free}{ acquisition.  The data section might contain equal length or variable length }{\ul\cf11 sweeps}{\v Sweep}{ of data.  The Synch Array contains a record to indicate the start time and length of every sweep or Event in the data }{\ul\cf11 file}{\v File}{.  The ABF reading routines automatically decode the Synch Array when providing information about the data.
{\v0\par\v}A Synch array is created and used in the following acquisition modes: ABF_VARLENEVENTS, ABF_FIXLENEVENTS & ABF_HIGHSPEEDOSC.  The acquisition modes ABF_GAPFREEFILE and ABF_WAVEFORMFILE do not always use a Synch array.
{\v0\par\v}}\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFSynch Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(8 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2977\clvertalt\cltxlrtb \cellx3969\clvertalt\cltxlrtb \cellx8080\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2977\clvertalt\cltxlrtb \cellx3969\clvertalt\cltxlrtb \cellx8080\pard \sb120\widctlpar\intbl\adjustright {0\cell lStart\cell }{\ul\cf11 long}{\v long}{\cell Start time of }{\ul\cf11 sweep}{\v Sweep}{ in fSynchTimeUnit}{\field\flddirty{\*\fldinst { \\Relate "ABFAPI.DOC!1", "fSynchTimeUnit" }}{\fldrslt }}{ units.\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2977\clvertalt\cltxlrtb \cellx3969\clvertalt\cltxlrtb \cellx8080\pard \sb120\widctlpar\intbl\adjustright {4\cell lLength\cell }{\ul\cf11 long}{\v long}{\cell Length of the sweep in multiplexed samples.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ The_ABF_Tag_Section}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ The ABF Tag Section}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ The ABF Tag Section;ABFTag }}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Tag Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {During an acquisition, some programs allow the user to tag points of interest in the input data stream. These tags are saved in the Tag Section.  Each tag consists of a time stamp, a text comment, and a tag type identifier.  If the tag is a voice tag, the data is held in an ABFVoiceTagInfo struct. 
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFTag Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid { (64 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3261\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3261\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard \sb120\widctlpar\intbl\adjustright {0\cell lTagTime\cell }{\ul\cf11 long}{\v long}{\cell Time at which the tag was entered in fSynchTimeUnit}{\field\flddirty{\*\fldinst { \\Relate "ABFAPI.DOC!1", "fSynchTimeUnit" }}{\fldrslt }}{ units.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {4\cell sComment\cell 56}{\ul\cf11 char}{\cell Optional comment to describe the tag.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {60\cell nTagType\cell }{\ul\cf11 short}{\v short}{\cell Type of tag. Valid types are ABF_TIMETAG=0, ABF_COMMENTTAG=1, ABF_EXTERNALTAG=2, ABF_VOICETAG=3\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx3261\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard \sb120\widctlpar\intbl\adjustright {62\cell nVoiceTagNumber\cell }{\ul\cf11 short}{\v short}{\cell If nTagType=ABF_VOICETAG, this is the number of this voice tag.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFVoiceTagInfo structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(32 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx993\clvertalt\cltxlrtb \cellx3261\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx959\clvertalt\cltxlrtb \cellx3227\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 0\cell lTagNumber\cell }{\fs20\ul\cf11 long}{\v\fs20 long}{\fs20  \cell The tag number that corresponds to this VoiceTag\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 4\cell lFileOffset\cell long\cell Offset to this tag within the VoiceTag block\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 8\cell lUncompressedSize\cell long\cell Size of the voice tag expanded.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 12\cell lCompressedSize\cell long\cell Compressed size of the tag.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 16\cell nCompressionType\cell }{\fs20\ul\cf11 short}{\v\fs20 short}{\fs20  \cell Compression method used.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 18\cell nSampleSize\cell short\cell Size of the samples acquired.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 20\cell lSamplesPerSecond\cell long\cell Rate at which the sound was acquired.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 24\cell dwCRC\cell }{\fs20\ul\cf11 DWORD}{\v\fs20 DWORD}{\fs20  \cell CRC used to check data integrity.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 28\cell wChannels\cell }{\fs20\ul\cf11 WORD}{\v\fs20 WORD}{\fs20  \cell Number of channels in the tag (usually 1).\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx959\clvertalt\cltxlrtb \cellx3227\clvertalt\cltxlrtb \cellx4253\clvertalt\cltxlrtb \cellx9214\pard\plain \s16\li74\ri74\sb40\sa40\widctlpar\intbl\adjustright \f1\fs22\cgrid {\fs20 30\cell wUnused\cell WORD\cell Unused space.\cell }\pard\plain \widctlpar\intbl\adjustright \f1\fs20\cgrid {\row }\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super #}{ The_ABF_Deltas_Section}}}{ }{\cs20\super ${\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super $}{ The ABF Deltas Section}}}{ }{\cs20\super K{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super K}{ The ABF Deltas Section;ABFDelta }}}{ }{\cs20\super +{\footnote \pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The ABF Deltas Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {When acquisition parameters are changed during an acquisition, the changes are tracked and entered in the ABF deltas section. Each entry is time stamped in fSynchTimeUnit}{\field\flddirty{\*\fldinst { \\Relate "ABFAPI.DOC!1", "fSynchTimeUnit" }}{\fldrslt }}{ units, so that the value of the parameter can be determined at any point during the acquisition.
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid {The ABFDelta Structure
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {(64 bytes).
\par }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx3828\clvertalt\cltxlrtb \cellx8505\pard \sb120\widctlpar\intbl\adjustright {\b Offset\cell Header Entry Name\cell Type\cell Description\cell }\pard \widctlpar\intbl\adjustright {\b \row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx3828\clvertalt\cltxlrtb \cellx8505\pard \sb120\widctlpar\intbl\adjustright {0\cell lDeltaTime\cell }{\ul\cf11 long}{\v long}{\cell Time at which the parameter was changed in fSynchTimeUnit}{\field\flddirty{\*\fldinst { \\Relate "ABFAPI.DOC!1", "fSynchTimeUnit" }}{\fldrslt }}{ units.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard \sb120\widctlpar\intbl\adjustright {4\cell lParameterID\cell }{\ul\cf11 long}{\v long}{\cell Identifier for the parameter changed.\line Legal parameter values are:\line ABF_DELTA_XXXXXXXX\cell }\pard \widctlpar\intbl\adjustright {\row }\trowd \trkeep \clvertalt\cltxlrtb \cellx934\clvertalt\cltxlrtb \cellx2835\clvertalt\cltxlrtb \cellx3828\clvertalt\cltxlrtb \cellx8505\pard \sb120\widctlpar\intbl\adjustright {8\cell lNewParamValue\line fNewParamValue\cell }{\ul\cf11 long}{\v long}{\line }{\ul\cf11 float}{\v float}{\cell Depending on the value of lParameterID this entry may be either a }{\ul\cf11 float}{\v float}{ or a }{\ul\cf11 long}{\v long}{.\cell }\pard \widctlpar\intbl\adjustright {\row }\pard\plain \s1\sb60\sa120\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ The_DAC_Data_Section}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ The DAC Data Section}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ The DAC Data Section}}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ The DAC Data Section
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {In some experiments, instead of the analog output stimulation waveform being described parametrically in a table it is described on a }{\ul\cf11 sample}{\v Sample}{-by-sample basis from a file.  In experiments where files are used to describe the analog output stimulation, a copy of the stimulation file is attached in the }{\ul\cf11 DAC}{\v DAC_D_A}{ Data section to ensure that the stimulus waveform is always available during analysis. The ABF routines allow reading of the DAC data with separate functions similar to those of }{\uldb\cf11 ABF_ReadChannel}{\v ABF_ReadChannel}{ (i.e. called }{\uldb\cf11 ABF_ReadDACFileEpi}{\v ABF_ReadDACFileEpi}{).
{\v0\par\v}}\pard\plain \s1\sb60\sa120\keepn\widctlpar\outlinelevel0\adjustright \b\f1\fs28\cgrid {\page }{\cs20\super #{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super #}{ ABFHEADR_H}}}{ }{\cs20\super ${\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super $}{ ABFHEADR.H}}}{ }{\cs20\super K{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super K}{ ABFHEADR.H}}}{ }{\cs20\super +{\footnote \pard\plain \s19\sb120\widctlpar\adjustright \f9\fs20\cgrid {\cs20\super +}{ ABFFUNC}}}{ ABFHEADR.H
\par }\pard\plain \s18\widctlpar\adjustright \f2\fs18\cgrid {//***********************************************************************************************
\par //
\par //    Copyright (c) 1993-1997 Axon Instruments.
\par //    All rights reserved.
\par //    Permission is granted to freely to use, modify and copy the code in this file.
\par //
\par //***********************************************************************************************
\par // HEADER:  ABFHEADR.H.
\par // PURPOSE: Defines the ABFFileHeader structure, and provides prototypes for
\par //          functions implemented in ABFHEADR.CPP for reading and writing
\par //          ABFFileHeader's.
\par // REVISIONS:
\par //   1.3  - Change 4-byte sFileType string to long lFileSignature.
\par //        - #define ABF_NATIVESIGNATURE & ABF_REVERSESIGNATURE for byte order detection.
\par //   1.4  - Remove support for big-endian machines.
\par //   1.5  - Change ABFSignal parameters from UUTop & UUBottom to
\par //          fDisplayGain & fDisplayOffset.
\par 
\par #ifndef INC_ABFHEADR_H
\par #define INC_ABFHEADR_H
\par 
\par #include "AxAbffio32.h"
\par 
\par #ifdef __cplusplus
\par extern "C" \{
\par #endif
\par 
\par //
\par // Constants used in defining the ABF file header
\par //
\par 
\par #define ABF_ADCCOUNT           16    // number of ADC channels supported.
\par #define ABF_DACCOUNT           4     // number of DAC channels supported.
\par #define ABF_EPOCHCOUNT         10    // number of DAC channels supported.
\par #define ABF_BELLCOUNT          2     // Number of auditory signals supported.
\par #define ABF_ADCUNITLEN         8     // length of ADC units strings
\par #define ABF_ADCNAMELEN         10    // length of ADC channel name strings
\par #define ABF_DACUNITLEN         8     // length of DAC units strings
\par #define ABF_DACNAMELEN         10    // length of DAC channel name strings
\par #define ABF_VARPARAMLISTLEN    80    // length of conditioning string
\par #define ABF_FILECOMMENTLEN     56    // length of file comment string
\par #define ABF_CREATORINFOLEN     16    // length of file creator info string
\par #define ABF_OLDDACFILENAMELEN  12    // old length of the DACFile name string
\par #define ABF_OLDDACFILEPATHLEN  60    // old length of the DACFile path string
\par #define ABF_DACFILEPATHLEN     84    // length of full path for DACFile
\par #define ABF_ARITHMETICOPLEN    2     // length of the Arithmetic operator field
\par #define ABF_ARITHMETICUNITSLEN 8     // length of arithmetic units string
\par #define ABF_TAGCOMMENTLEN      56    // length of tag comment string
\par #define ABF_LONGDESCRIPTIONLEN 56    // length of long description entry
\par #define ABF_NOTENAMELEN        10    // length of the name component of a note
\par #define ABF_NOTEVALUELEN       8     // length of the value component of a note
\par #define ABF_NOTEUNITSLEN       8     // length of the units component of a note
\par #define ABF_BLOCKSIZE          512   // Size of block allignment in ABF files.
\par 
\par #define ABF_CURRENTVERSION     1.5F           // File format version number
\par #define ABF_HEADERSIZE         2048            // Size of a Version 1.x header
\par #define ABF_NATIVESIGNATURE    0x20464241      // PC="ABF ", MAC=" FBA"
\par #define ABF_REVERSESIGNATURE   0x41424620      // PC=" FBA", MAC="ABF "
\par 
\par #define PCLAMP6_MAXSWEEPLENGTH 16384 // Maximum multiplexed sweep length supported by pCLAMP6 apps.
\par 
\par #define ABF_MAX_TRIAL_SAMPLES  0x7FFFFFFF    // Maximum length of acquisition supported (samples)
\par                                              // INT_MAX is used instead of UINT_MAX because of the signed 
\par                                              // values in the ABF header.
\par 
\par #define ABF_MAX_SWEEPS_PER_AVERAGE 65500     // The maximum number of sweeps that can be combined into a
\par                                              // cumulative average (nAverageAlgorithm=ABF_INFINITEAVERAGE).
\par 
\par #ifdef _MAC
\par    #define ABF_OLDPCLAMP        ABF_REVERSESIGNATURE
\par #else
\par    #define ABF_OLDPCLAMP        ABF_NATIVESIGNATURE
\par #endif
\par 
\par //
\par // Constant definitions for nFileType
\par //
\par 
\par #define ABF_ABFFILE          1
\par #define ABF_FETCHEX          2
\par #define ABF_CLAMPEX          3
\par 
\par //
\par // Constant definitions for nDataFormat
\par //
\par #define ABF_INTEGERDATA      0
\par #define ABF_FLOATDATA        1
\par 
\par //
\par // Constant definitions for nOperationMode
\par //
\par #define ABF_VARLENEVENTS     1
\par #define ABF_FIXLENEVENTS     2     // (ABF_FIXLENEVENTS == ABF_LOSSFREEOSC)
\par #define ABF_LOSSFREEOSC      2
\par #define ABF_GAPFREEFILE      3
\par #define ABF_HIGHSPEEDOSC     4
\par #define ABF_WAVEFORMFILE     5
\par 
\par //
\par // Constant definitions for nParamToVary
\par //
\par #define ABF_CONDITNUMPULSES         0
\par #define ABF_CONDITBASELINEDURATION  1
\par #define ABF_CONDITBASELINELEVEL     2
\par #define ABF_CONDITSTEPDURATION      3
\par #define ABF_CONDITSTEPLEVEL         4
\par #define ABF_CONDITPOSTTRAINDURATION 5
\par #define ABF_CONDITPOSTTRAINLEVEL    6
\par #define ABF_EPISODESTARTTOSTART     7
\par #define ABF_INACTIVEHOLDING         8
\par #define ABF_DIGITALHOLDING          9
\par #define ABF_PNNUMPULSES             10
\par #define ABF_PARALLELVALUE           11
\par #define ABF_EPOCHINITLEVEL          21
\par #define ABF_EPOCHINITDURATION       31
\par 
\par //
\par // Constants for nAveragingMode
\par //
\par #define ABF_NOAVERAGING       0
\par #define ABF_SAVEAVERAGEONLY   1
\par #define ABF_AVERAGESAVEALL    2
\par 
\par //
\par // Constants for nAverageAlgorithm
\par //
\par #define ABF_INFINITEAVERAGE   0
\par #define ABF_SLIDINGAVERAGE    1
\par 
\par //
\par // Constants for nEpochType
\par //
\par #define ABF_EPOCHDISABLED     0               // disabled epoch
\par #define ABF_EPOCHSTEPPED      1               // stepped waveform
\par #define ABF_EPOCHRAMPED       2               // ramp waveform
\par 
\par //
\par // Constants for nWaveformSource
\par //
\par #define ABF_WAVEFORMDISABLED     0               // disabled waveform
\par #define ABF_EPOCHTABLEWAVEFORM   1
\par #define ABF_DACFILEWAVEFORM      2
\par 
\par //
\par // Constants for nInterEpisodeLevel & nDigitalInterEpisode
\par //
\par #define ABF_INTEREPI_USEHOLDING    0
\par #define ABF_INTEREPI_USELASTEPOCH  1
\par 
\par //
\par // Constants for nExperimentType
\par //
\par #define ABF_VOLTAGECLAMP         0
\par #define ABF_CURRENTCLAMP         1
\par #define ABF_SIMPLEACQUISITION    2
\par 
\par //
\par // Constants for nAutosampleEnable
\par //
\par #define ABF_AUTOSAMPLEDISABLED   0
\par #define ABF_AUTOSAMPLEAUTOMATIC  1
\par #define ABF_AUTOSAMPLEMANUAL     2
\par 
\par //
\par // Constants for nAutosampleInstrument
\par //
\par #define ABF_INST_UNKNOWN         0   // Unknown instrument (manual or user defined telegraph table).
\par #define ABF_INST_AXOPATCH1       1   // Axopatch-1 with CV-4-1/100
\par #define ABF_INST_AXOPATCH1_1     2   // Axopatch-1 with CV-4-0.1/100
\par #define ABF_INST_AXOPATCH1B      3   // Axopatch-1B(inv.) CV-4-1/100
\par #define ABF_INST_AXOPATCH1B_1    4   // Axopatch-1B(inv) CV-4-0.1/100
\par #define ABF_INST_AXOPATCH201     5   // Axopatch 200 with CV 201
\par #define ABF_INST_AXOPATCH202     6   // Axopatch 200 with CV 202
\par #define ABF_INST_GENECLAMP       7   // GeneClamp
\par #define ABF_INST_DAGAN3900       8   // Dagan 3900
\par #define ABF_INST_DAGAN3900A      9   // Dagan 3900A
\par #define ABF_INST_DAGANCA1_1      10  // Dagan CA-1  Im=0.1
\par #define ABF_INST_DAGANCA1        11  // Dagan CA-1  Im=1.0
\par #define ABF_INST_DAGANCA10       12  // Dagan CA-1  Im=10
\par #define ABF_INST_WARNER_OC725    13  // Warner OC-725
\par #define ABF_INST_WARNER_OC725C   14  // Warner OC-725
\par #define ABF_INST_AXOPATCH200B    15  // Axopatch 200B
\par #define ABF_INST_DAGANPCONE0_1   16  // Dagan PC-ONE  Im=0.1
\par #define ABF_INST_DAGANPCONE1     17  // Dagan PC-ONE  Im=1.0
\par #define ABF_INST_DAGANPCONE10    18  // Dagan PC-ONE  Im=10
\par #define ABF_INST_DAGANPCONE100   19  // Dagan PC-ONE  Im=100
\par #define ABF_INST_WARNER_BC525C   20  // Warner BC-525C
\par #define ABF_INST_WARNER_PC505    21  // Warner PC-505
\par #define ABF_INST_WARNER_PC501    22  // Warner PC-501
\par #define ABF_INST_DAGANCA1_05     23  // Dagan CA-1  Im=0.05
\par 
\par //
\par // Constants for nManualInfoStrategy
\par //
\par #define ABF_ENV_DONOTWRITE      0
\par #define ABF_ENV_WRITEEACHTRIAL  1
\par #define ABF_ENV_PROMPTEACHTRIAL 2
\par 
\par //
\par // Constants for nTriggerSource
\par //
\par #define ABF_TRIGGERTAGINPUT      -4
\par #define ABF_TRIGGERFIRSTCHANNEL  -3
\par #define ABF_TRIGGEREXTERNAL      -2
\par #define ABF_TRIGGERSPACEBAR      -1
\par // >=0 = ADC channel to trigger off.
\par 
\par //
\par // Constants for nTrialTriggerSource
\par //
\par #define ABF_TRIALTRIGGER_SPACEBAR  -3   // Start on spacebar press.
\par #define ABF_TRIALTRIGGER_EXTERNAL  -2   // Start on external trigger high
\par #define ABF_TRIALTRIGGER_NONE      -1   // Start immediately (default).
\par // >=0 = ADC channel to trigger off.    // Not implemented as yet...
\par 
\par //
\par // Constants for nTriggerPolarity.
\par //
\par #define ABF_TRIGGER_RISINGEDGE  0
\par #define ABF_TRIGGER_FALLINGEDGE 1
\par 
\par //
\par // Constants for nTriggerAction
\par //
\par #define ABF_TRIGGER_STARTEPISODE 0
\par #define ABF_TRIGGER_STARTRUN     1
\par #define ABF_TRIGGER_STARTTRIAL   2    // N.B. Discontinued in favour of nTrialTriggerSource
\par 
\par //
\par // Constants for nDrawingStrategy
\par //
\par #define ABF_DRAW_NONE            0
\par #define ABF_DRAW_REALTIME        1
\par #define ABF_DRAW_FULLSCREEN      2
\par #define ABF_DRAW_ENDOFRUN        3
\par 
\par //
\par // Constants for nTiledDisplay
\par //
\par #define ABF_DISPLAY_SUPERIMPOSED 0
\par #define ABF_DISPLAY_TILED        1
\par 
\par //
\par // Constants for nDataDisplayMode
\par //
\par #define ABF_DRAW_POINTS       0
\par #define ABF_DRAW_LINES        1
\par 
\par //
\par // Constants for nArithmeticExpression
\par //
\par #define ABF_SIMPLE_EXPRESSION    0
\par #define ABF_RATIO_EXPRESSION     1
\par 
\par //
\par // Constants for nLowpassFilterType & nHighpassFilterType
\par //
\par #define ABF_FILTER_NONE          0
\par #define ABF_FILTER_EXTERNAL      1
\par #define ABF_FILTER_SIMPLE_RC     2
\par #define ABF_FILTER_BESSEL        3
\par #define ABF_FILTER_BUTTERWORTH   4
\par 
\par //
\par // Constants for nPNPosition
\par //
\par #define ABF_PN_BEFORE_EPISODE    0
\par #define ABF_PN_AFTER_EPISODE     1
\par 
\par //
\par // Constants for nPNPolarity
\par //
\par #define ABF_PN_OPPOSITE_POLARITY -1
\par #define ABF_PN_SAME_POLARITY     1
\par 
\par //
\par // Constants for nAutopeakPolarity
\par //
\par #define ABF_PEAK_NEGATIVE       -1
\par #define ABF_PEAK_ABSOLUTE        0
\par #define ABF_PEAK_POSITIVE        1
\par 
\par //
\par // Constants for nAutopeakSearchMode
\par //
\par #define ABF_PEAK_SEARCH_SPECIFIED   -2
\par #define ABF_PEAK_SEARCH_ALL         -1
\par 
\par //
\par // Constants for nAutopeakBaseline
\par //
\par #define ABF_PEAK_BASELINE_SPECIFIED    -3
\par #define ABF_PEAK_BASELINE_NONE \tab       -2
\par #define ABF_PEAK_BASELINE_FIRSTHOLDING -1
\par #define ABF_PEAK_BASELINE_LASTHOLDING  -4
\par 
\par //
\par // Constants for lAutopeakMeasurements
\par //
\par #define ABF_PEAK_MEASURE_PEAK             0x00000001
\par #define ABF_PEAK_MEASURE_PEAKTIME         0x00000002
\par #define ABF_PEAK_MEASURE_ANTIPEAK         0x00000004
\par #define ABF_PEAK_MEASURE_ANTIPEAKTIME     0x00000008
\par #define ABF_PEAK_MEASURE_MEAN             0x00000010
\par #define ABF_PEAK_MEASURE_STDDEV           0x00000020
\par #define ABF_PEAK_MEASURE_INTEGRAL         0x00000040
\par #define ABF_PEAK_MEASURE_LEFTSLOPE        0x00000080
\par #define ABF_PEAK_MEASURE_LEFTSLOPETIME    0x00000100
\par #define ABF_PEAK_MEASURE_RIGHTSLOPE       0x00000200
\par #define ABF_PEAK_MEASURE_RIGHTSLOPETIME   0x00000400
\par #define ABF_PEAK_MEASURE_RISETIME         0x00000800
\par #define ABF_PEAK_MEASURE_DECAYTIME        0x00001000
\par #define ABF_PEAK_MEASURE_HALFWIDTH        0x00002000
\par #define ABF_PEAK_MEASURE_BASELINE         0x00004000
\par 
\par //
\par // Constants for lStatisticsMeasurements
\par //
\par #define ABF_STATISTICS_ABOVETHRESHOLD     0x00000001
\par #define ABF_STATISTICS_EVENTFREQUENCY     0x00000002
\par #define ABF_STATISTICS_MEANOPENTIME       0x00000004
\par #define ABF_STATISTICS_MEANCLOSEDTIME     0x00000008
\par 
\par //
\par // Constants for nStatisticsSaveStrategy
\par //
\par #define ABF_STATISTICS_NOAUTOSAVE   0
\par #define ABF_STATISTICS_AUTOSAVE     1
\par 
\par //
\par // Constants for nStatisticsDisplayStrategy
\par //
\par #define ABF_STATISTICS_DISPLAY      0
\par #define ABF_STATISTICS_NODISPLAY    1
\par 
\par //
\par // Constants for nDACFileEpisodeNum
\par //
\par #define ABF_DACFILE_SKIPFIRSTSWEEP -1
\par #define ABF_DACFILE_USEALLSWEEPS    0
\par // >0 = The specific sweep number.
\par 
\par //
\par // Constants for nUndoPromptStrategy
\par //
\par #define ABF_UNDOPROMPT_ONABORT   0
\par #define ABF_UNDOPROMPT_ALWAYS    1
\par 
\par //
\par // Miscellaneous constants
\par //
\par #define ABF_FILTERDISABLED  100000.0F     // Large frequency to disable lowpass filters
\par 
\par //
\par // pack structure on byte boundaries
\par //
\par #ifndef RC_INVOKED
\par #pragma pack(1)
\par #endif
\par 
\par //
\par // Definition of the ABF header structure.
\par //
\par 
\par struct ABFFileHeader               // The total header length = 2048 bytes.
\par \{
\par    // GROUP #1 - File ID and size information. (40 bytes)
\par    long     lFileSignature;
\par    float    fFileVersionNumber;
\par    short    nOperationMode;
\par    long     lActualAcqLength;
\par    short    nNumPointsIgnored;
\par    long     lActualEpisodes;
\par    long     lFileStartDate;
\par    long     lFileStartTime;
\par    long     lStopwatchTime;
\par    float    fHeaderVersionNumber;
\par    short    nFileType;
\par    short    nMSBinFormat;
\par 
\par    // GROUP #2 - File Structure (80 bytes)
\par    long     lDataSectionPtr;
\par    long     lTagSectionPtr;
\par    long     lNumTagEntries;
\par    long     lScopeConfigPtr;
\par    long     lNumScopes;
\par    long     lDACFilePtr;
\par    long     lDACFileNumEpisodes;
\par    char     sUnused68[4];
\par    long     lDeltaArrayPtr;
\par    long     lNumDeltas;
\par    long     lVoiceTagPtr;
\par    long     lVoiceTagEntries;
\par    long     lUnused88;
\par    long     lSynchArrayPtr;
\par    long     lSynchArraySize;
\par    short    nDataFormat;
\par    short    nSimultaneousScan;
\par    long     lStatisticsConfigPtr;
\par    char     sUnused108[12];
\par 
\par    // GROUP #3 - Trial hierarchy information (80 bytes)
\par    short    nADCNumChannels;
\par    float    fADCSampleInterval;
\par    float    fADCSecondSampleInterval;
\par    float    fSynchTimeUnit;
\par    float    fSecondsPerRun;
\par    long     lNumSamplesPerEpisode;
\par    long     lPreTriggerSamples;
\par    long     lEpisodesPerRun;
\par    long     lRunsPerTrial;
\par    long     lNumberOfTrials;
\par    short    nAveragingMode;
\par    short    nUndoRunCount;
\par    short    nFirstEpisodeInRun;
\par    float    fTriggerThreshold;
\par    short    nTriggerSource;
\par    short    nTriggerAction;
\par    short    nTriggerPolarity;
\par    float    fScopeOutputInterval;
\par    float    fEpisodeStartToStart;
\par    float    fRunStartToStart;
\par    float    fTrialStartToStart;
\par    long     lAverageCount;
\par    long     lClockChange;
\par    short    nAutoTriggerStrategy;
\par 
\par    // GROUP #4 - Display Parameters (44 bytes)
\par    short    nDrawingStrategy;
\par    short    nTiledDisplay;
\par    short    nEraseStrategy;           // N.B. Discontinued. Use scope config entry instead.
\par    short    nDataDisplayMode;
\par    long     lDisplayAverageUpdate;
\par    short    nChannelStatsStrategy;
\par    long     lCalculationPeriod;       // N.B. Discontinued. Use fStatisticsPeriod.
\par    long     lSamplesPerTrace;
\par    long     lStartDisplayNum;
\par    long     lFinishDisplayNum;
\par    short    nMultiColor;
\par    short    nShowPNRawData;
\par    float    fStatisticsPeriod;
\par    long     lStatisticsMeasurements;
\par    short    nStatisticsSaveStrategy;
\par 
\par    // GROUP #5 - Hardware information (16 bytes)
\par    float    fADCRange;
\par    float    fDACRange;
\par    long     lADCResolution;
\par    long     lDACResolution;
\par 
\par    // GROUP #6 Environmental Information (118 bytes)
\par    short    nExperimentType;
\par    short    nAutosampleEnable;
\par    short    nAutosampleADCNum;
\par    short    nAutosampleInstrument;
\par    float    fAutosampleAdditGain;
\par    float    fAutosampleFilter;
\par    float    fAutosampleMembraneCap;
\par    short    nManualInfoStrategy;
\par    float    fCellID1;
\par    float    fCellID2;
\par    float    fCellID3;
\par    char     sCreatorInfo[ABF_CREATORINFOLEN];
\par    char     sFileComment[ABF_FILECOMMENTLEN];
\par    short    nFileStartMillisecs;    // Milliseconds portion of lFileStartTime
\par    char     sUnused338[10];
\par 
\par    // GROUP #7 - Multi-channel information (1044 (160 + 384 + 488 + 12) bytes)
\par    short    nADCPtoLChannelMap[ABF_ADCCOUNT];
\par    short    nADCSamplingSeq[ABF_ADCCOUNT];
\par    char     sADCChannelName[ABF_ADCCOUNT][ABF_ADCNAMELEN];
\par    char     sADCUnits[ABF_ADCCOUNT][ABF_ADCUNITLEN];
\par    float    fADCProgrammableGain[ABF_ADCCOUNT];
\par    float    fADCDisplayAmplification[ABF_ADCCOUNT];
\par    float    fADCDisplayOffset[ABF_ADCCOUNT];       
\par    float    fInstrumentScaleFactor[ABF_ADCCOUNT];  
\par    float    fInstrumentOffset[ABF_ADCCOUNT];       
\par    float    fSignalGain[ABF_ADCCOUNT];
\par    float    fSignalOffset[ABF_ADCCOUNT];
\par    float    fSignalLowpassFilter[ABF_ADCCOUNT];
\par    float    fSignalHighpassFilter[ABF_ADCCOUNT];
\par    char     sDACChannelName[ABF_DACCOUNT][ABF_DACNAMELEN];
\par    char     sDACChannelUnits[ABF_DACCOUNT][ABF_DACUNITLEN];
\par    float    fDACScaleFactor[ABF_DACCOUNT];
\par    float    fDACHoldingLevel[ABF_DACCOUNT];
\par    short    nSignalType;
\par    char     sUnused1412[10];
\par 
\par    // GROUP #8 - Synchronous timer outputs (14 bytes)
\par    short    nOUTEnable;
\par    short    nSampleNumberOUT1;
\par    short    nSampleNumberOUT2;
\par    short    nFirstEpisodeOUT;
\par    short    nLastEpisodeOUT;
\par    short    nPulseSamplesOUT1;
\par    short    nPulseSamplesOUT2;
\par 
\par    // GROUP #9 - Epoch Waveform and Pulses (184 bytes)
\par    short    nDigitalEnable;
\par    short    nWaveformSource;
\par    short    nActiveDACChannel;
\par    short    nInterEpisodeLevel;
\par    short    nEpochType[ABF_EPOCHCOUNT];
\par    float    fEpochInitLevel[ABF_EPOCHCOUNT];
\par    float    fEpochLevelInc[ABF_EPOCHCOUNT];
\par    short    nEpochInitDuration[ABF_EPOCHCOUNT];
\par    short    nEpochDurationInc[ABF_EPOCHCOUNT];
\par    short    nDigitalHolding;
\par    short    nDigitalInterEpisode;
\par    short    nDigitalValue[ABF_EPOCHCOUNT];
\par    char     sUnavailable1608[4];    // was float fWaveformOffset;
\par    char     sUnused1612[8];
\par 
\par    // GROUP #10 - DAC Output File (98 bytes)
\par    float    fDACFileScale;
\par    float    fDACFileOffset;
\par    char     sUnused1628[2];
\par    short    nDACFileEpisodeNum;
\par    short    nDACFileADCNum;
\par    char     sDACFilePath[ABF_DACFILEPATHLEN];
\par 
\par    // GROUP #11 - Conditioning pulse train (44 bytes)
\par    short    nConditEnable;
\par    short    nConditChannel;
\par    long     lConditNumPulses;
\par    float    fBaselineDuration;
\par    float    fBaselineLevel;
\par    float    fStepDuration;
\par    float    fStepLevel;
\par    float    fPostTrainPeriod;
\par    float    fPostTrainLevel;
\par    char     sUnused1750[12];
\par 
\par    // GROUP #12 - Variable parameter user list ( 82 bytes)
\par    short    nParamToVary;
\par    char     sParamValueList[ABF_VARPARAMLISTLEN];
\par 
\par    // GROUP #13 - Autopeak measurement (36 bytes)
\par    short    nAutopeakEnable;
\par    short    nAutopeakPolarity;
\par    short    nAutopeakADCNum;
\par    short    nAutopeakSearchMode;
\par    long     lAutopeakStart;
\par    long     lAutopeakEnd;
\par    short    nAutopeakSmoothing;
\par    short    nAutopeakBaseline;
\par    short    nAutopeakAverage;
\par    char     sUnavailable1866[2];     // Was nAutopeakSaveStrategy, use nStatisticsSaveStrategy
\par    long     lAutopeakBaselineStart;
\par    long     lAutopeakBaselineEnd;
\par    long     lAutopeakMeasurements;
\par 
\par    // GROUP #14 - Channel Arithmetic (52 bytes)
\par    short    nArithmeticEnable;
\par    float    fArithmeticUpperLimit;
\par    float    fArithmeticLowerLimit;
\par    short    nArithmeticADCNumA;
\par    short    nArithmeticADCNumB;
\par    float    fArithmeticK1;
\par    float    fArithmeticK2;
\par    float    fArithmeticK3;
\par    float    fArithmeticK4;
\par    char     sArithmeticOperator[ABF_ARITHMETICOPLEN];
\par    char     sArithmeticUnits[ABF_ARITHMETICUNITSLEN];
\par    float    fArithmeticK5;
\par    float    fArithmeticK6;
\par    short    nArithmeticExpression;
\par    char     sUnused1930[2];
\par 
\par    // GROUP #15 - On-line subtraction (34 bytes)
\par    short    nPNEnable;
\par    short    nPNPosition;
\par    short    nPNPolarity;
\par    short    nPNNumPulses;
\par    short    nPNADCNum;
\par    float    fPNHoldingLevel;
\par    float    fPNSettlingTime;
\par    float    fPNInterpulse;
\par    char     sUnused1954[12];
\par 
\par    // GROUP #16 - Unused space at end of header block (54 bytes)
\par    short    nListEnable;
\par    
\par    short    nBellEnable[ABF_BELLCOUNT];
\par    short    nBellLocation[ABF_BELLCOUNT];
\par    short    nBellRepetitions[ABF_BELLCOUNT];
\par    
\par    short    nLevelHysteresis;
\par    long     lTimeHysteresis;
\par    short    nAllowExternalTags;
\par    
\par    char     nLowpassFilterType[ABF_ADCCOUNT];
\par    char     nHighpassFilterType[ABF_ADCCOUNT];
\par    short    nAverageAlgorithm;
\par    float    fAverageWeighting;
\par    short    nUndoPromptStrategy;
\par    short    nTrialTriggerSource;
\par    short    nStatisticsDisplayStrategy;
\par    short    nExternalTagType;
\par    char     sUnused2034[14];
\par \};    // Size = 2048
\par 
\par //
\par // Scope descriptor format.
\par //
\par #define ABF_FACESIZE 32
\par struct ABFLogFont
\par \{
\par    short nHeight;                // Height of the font in pixels.
\par //   short lWidth;               // use 0
\par //   short lEscapement;          // use 0
\par //   short lOrientation;         // use 0
\par    short nWeight;                // MSWindows font weight value.
\par //   char bItalic;               // use 0
\par //   char bUnderline;            // use 0
\par //   char bStrikeOut;            // use 0
\par //   char cCharSet;              // use ANSI_CHARSET (0)
\par //   char cOutPrecision;         // use OUT_TT_PRECIS
\par //   char cClipPrecision;        // use CLIP_DEFAULT_PRECIS
\par //   char cQuality;              // use PROOF_QUALITY
\par    char cPitchAndFamily;         // MSWindows pitch and family mask.
\par    char Unused[3];               // Unused space to maintain 4-byte packing.
\par    char szFaceName[ABF_FACESIZE];// Face name of the font.
\par \};     // Size = 40
\par 
\par struct ABFSignal
\par \{
\par    char     szName[ABF_ADCNAMELEN+2];        // ABF name length + '\\0' + 1 for alignment.
\par    short    nMxOffset;                       // Offset of the signal in the sampling sequence.
\par    DWORD    rgbColor;                        // Pen color used to draw trace.
\par    char     nPenWidth;                       // Pen width in pixels.
\par    char     bDrawPoints;                     // TRUE = Draw disconnected points
\par    char     bHidden;                         // TRUE = Hide the trace.
\par    char     bFloatData;                      // TRUE = Floating point pseudo channel
\par    float    fVertProportion;                 // Relative proportion of client area to use
\par    float    fDisplayGain;                    // Display gain of trace in UserUnits
\par    float    fDisplayOffset;                  // Display offset of trace in UserUnits
\par 
\par //   float    fUUTop;                          // Top of window in UserUnits
\par //   float    fUUBottom;                       // Bottom of window in UserUnits
\par \};      // Size = 24
\par 
\par // Bit flags used in dwFlags field of ABFScopeConfig.
\par #define ABF_OVERLAPPED      0x00000001
\par #define ABF_DONTERASE       0x00000002
\par #define ABF_MONOCHROME      0x00000004
\par #define ABF_CLIPPING        0x00000008
\par #define ABF_HIDEHORZGRIDS   0x00000010
\par #define ABF_HIDEVERTGRIDS   0x00000020
\par #define ABF_FULLSCREEN      0x00000040
\par #define ABF_HIDEXAXIS       0x00000080
\par #define ABF_HIDEYAXIS       0x00000100
\par #define ABF_HIDEXSCROLL     0x00000200
\par #define ABF_HIDEYSCROLL     0x00000400
\par #define ABF_HIDESIGNALNAME  0x00000800
\par #define ABF_ENABLEZOOM      0x00001000
\par #define ABF_XSPINFROMCENTER 0x00002000
\par #define ABF_HIDEXSPINNER    0x00004000
\par #define ABF_LARGESPINNERS   0x00008000
\par #define ABF_PERSISTENCEMODE 0x00010000
\par #define ABF_CARDIACMODE     0x00020000
\par #define ABF_HIDETWIRLER     0x00040000
\par #define ABF_DISABLEUI       0x00080000
\par 
\par // Values for the wScopeMode field in ABFScopeConfig.
\par #define ABF_EPISODICMODE    0
\par #define ABF_CONTINUOUSMODE  1
\par //#define ABF_XYMODE          2
\par 
\par // Values for the nEraseStrategy field in ABFScopeConfig.
\par #define ABF_ERASE_EACHSWEEP   0
\par #define ABF_ERASE_EACHRUN     1
\par #define ABF_ERASE_EACHTRIAL   2
\par #define ABF_ERASE_DONTERASE   3
\par 
\par // Indexes into the rgbColor field of ABFScopeConfig.
\par #define ABF_BACKGROUNDCOLOR   0
\par #define ABF_GRIDCOLOR         1
\par #define ABF_THRESHOLDCOLOR    2
\par #define ABF_EVENTMARKERCOLOR  3
\par #define ABF_SEPARATORCOLOR    4
\par #define ABF_AVERAGECOLOR      5
\par #define ABF_OLDDATACOLOR      6
\par #define ABF_TEXTCOLOR         7
\par #define ABF_AXISCOLOR         8
\par #define ABF_ACTIVEAXISCOLOR   9
\par #define ABF_LASTCOLOR         ABF_ACTIVEAXISCOLOR
\par #define ABF_SCOPECOLORS       (ABF_LASTCOLOR+1)
\par 
\par // Values for the nDockState field in ABFScopeConfig
\par #define ABF_SCOPE_NOTDOCKED      0
\par #define ABF_SCOPE_DOCKED_TOP     1
\par #define ABF_SCOPE_DOCKED_LEFT    2
\par #define ABF_SCOPE_DOCKED_RIGHT   3
\par #define ABF_SCOPE_DOCKED_BOTTOM  4
\par 
\par struct ABFScopeConfig
\par \{
\par    DWORD       dwFlags;                   // Flags that are meaningful to the scope.
\par    DWORD       rgbColor[ABF_SCOPECOLORS]; // Colors for the components of the scope.
\par    float       fDisplayStart;             // Start of the display area in ms.
\par    float       fDisplayEnd;               // End of the display area in ms.
\par    WORD        wScopeMode;                // Mode that the scope is in.
\par    char        bMaximized;                // TRUE = Scope parent is maximized.
\par    char        bMinimized;                // TRUE = Scope parent is minimized.
\par    short       xLeft;                     // Coordinate of the left edge.
\par    short       yTop;                      // Coordinate of the top edge.
\par    short       xRight;                    // Coordinate of the right edge.
\par    short       yBottom;                   // Coordinate of the bottom edge.
\par    ABFLogFont  LogFont;                   // Description of current font.
\par    ABFSignal   TraceList[ABF_ADCCOUNT];   // List of traces in current use.
\par    short       nYAxisWidth;               // Width of the YAxis region.
\par    short       nTraceCount;               // Number of traces described in TraceList.
\par    short       nEraseStrategy;            // Erase strategy.
\par    short       nDockState;                // Docked position.
\par \}; // Size = 656
\par 
\par //
\par // Definition of the ABF synch array structure
\par //
\par 
\par struct ABFSynch
\par \{
\par    long    lStart;            // Start of the episode/event in fSynchTimeUnit units.
\par    long    lLength;           // Length of the episode/event in multiplexed samples.
\par \};
\par 
\par //
\par // Constants for nTagType in the ABFTag structure.
\par //
\par #define ABF_TIMETAG              0
\par #define ABF_COMMENTTAG           1
\par #define ABF_EXTERNALTAG          2
\par #define ABF_VOICETAG             3
\par 
\par //
\par // Definition of the ABF Tag structure
\par //
\par struct ABFTag
\par \{
\par    long    lTagTime;          // Time at which the tag was entered in fSynchTimeUnit units.
\par    char    sComment[ABF_TAGCOMMENTLEN];   // Optional tag comment.
\par    short   nTagType;          // Type of tag ABF_TIMETAG, ABF_COMMENTTAG, ABF_EXTERNALTAG or ABF_VOICETAG.
\par    short   nVoiceTagNumber;   // If nTagType=ABF_VOICETAG, this is the number of this voice tag.
\par \};
\par 
\par // Comment inserted for externally acquired tags (expanded with spaces to ABF_TAGCOMMENTLEN).
\par #define ABF_EXTERNALTAGCOMMENT   "<External>"
\par #define ABF_VOICETAGCOMMENT      "<Voice Tag>"
\par 
\par //
\par // Constants for nCompressionType in the ABFVoiceTagInfo structure.
\par //
\par #define ABF_COMPRESSION_NONE     0
\par #define ABF_COMPRESSION_PKWARE   1
\par //#define ABF_COMPRESSION_MPEG     2
\par 
\par //
\par // Definition of the ABFVoiceTagInfo structure.
\par //
\par struct ABFVoiceTagInfo
\par \{
\par    long  lTagNumber;          // The tag number that corresponds to this VoiceTag
\par    long  lFileOffset;         // Offset to this tag within the VoiceTag block
\par    long  lUncompressedSize;   // Size of the voice tag expanded.
\par    long  lCompressedSize;     // Compressed size of the tag.
\par    short nCompressionType;    // Compression method used.
\par    short nSampleSize;         // Size of the samples acquired.
\par    long  lSamplesPerSecond;   // Rate at which the sound was acquired.
\par    DWORD dwCRC;               // CRC used to check data integrity.
\par    WORD  wChannels;           // Number of channels in the tag (usually 1).
\par    WORD  wUnused;             // Unused space.
\par \};
\par 
\par //
\par // Constants for lParameterID in the ABFDelta structure.
\par //
\par // NOTE: If any changes are made to this list, the code in ABF_UpdateHeader must
\par //       be updated to include the new items.
\par #define ABF_DELTA_HOLDING0       0
\par #define ABF_DELTA_HOLDING1       1
\par #define ABF_DELTA_HOLDING2       2
\par #define ABF_DELTA_HOLDING3       3
\par #define ABF_DELTA_DIGITALOUTS    4
\par #define ABF_DELTA_THRESHOLD      5
\par #define ABF_DELTA_PRETRIGGER     6
\par 
\par //
\par // Definition of the ABF Delta structure.
\par //
\par 
\par struct ABFDelta
\par \{
\par    long    lDeltaTime;        // Time at which the parameter was changed in fSynchTimeUnit units.
\par    long    lParameterID;      // Identifier for the parameter changed
\par    union
\par    \{
\par       long  lNewParamValue;   // Depending on the value of lParameterID
\par       float fNewParamValue;   // this entry may be either a float or a long.
\par    \};
\par \};
\par 
\par #ifndef RC_INVOKED
\par #pragma pack()                      // return to default packing
\par #endif
\par 
\par //
\par // The size of the buffers to be passed to ABFH_GetWaveformVertor
\par //
\par #define ABFH_MAXVECTORS     30
\par 
\par 
\par //
\par // Function prototypes for functions in ABFHEADR.C
\par //
\par 
\par void WINAPI ABFH_Initialize( ABFFileHeader *pFH );
\par 
\par void WINAPI ABFH_InitializeScopeConfig(const ABFFileHeader *pFH, ABFScopeConfig *pCfg);
\par 
\par BOOL WINAPI ABFH_CheckScopeConfig(ABFFileHeader *pFH, ABFScopeConfig *pCfg);
\par 
\par void WINAPI ABFH_GetADCDisplayRange( const ABFFileHeader *pFH, int nChannel, 
\par                                      float *pfUUTop, float *pfUUBottom);
\par                                      
\par void WINAPI ABFH_GetADCtoUUFactors( const ABFFileHeader *pFH, int nChannel, 
\par                                     float *pfADCToUUFactor, float *pfADCToUUShift );
\par void WINAPI ABFH_ClipADCUUValue(const ABFFileHeader *pFH, int nChannel, float *pfUUValue);
\par                                            
\par void WINAPI ABFH_GetDACtoUUFactors( const ABFFileHeader *pFH, int nChannel, 
\par                                     float *pfDACToUUFactor, float *pfDACToUUShift );
\par void WINAPI ABFH_ClipDACUUValue(const ABFFileHeader *pFH, int nChannel, float *pfUUValue);
\par 
\par BOOL WINAPI ABFH_GetMathValue(const ABFFileHeader *pFH, float fA, float fB, float *pfRval);
\par int  WINAPI ABFH_GetMathChannelName(char *pszName, UINT uNameLen);
\par 
\par BOOL WINAPI ABFH_ParamReader( HANDLE hFile, ABFFileHeader *pFH, int *pnError );
\par BOOL WINAPI ABFH_ParamWriter( HANDLE hFile, ABFFileHeader *pFH, int *pnError );
\par 
\par BOOL WINAPI ABFH_GetErrorText( int nError, char *pszBuffer, UINT nBufferSize );
\par 
\par // ABFHWAVE.CPP
\par 
\par // Constants for ABFH_GetEpochLimits
\par #define ABFH_FIRSTHOLDING  -1
\par #define ABFH_LASTHOLDING   ABF_EPOCHCOUNT
\par 
\par // Return the bounds of a given epoch in a given episode. Values returned are ZERO relative.
\par BOOL WINAPI ABFH_GetEpochLimits(const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                                 int nEpoch, UINT *puEpochStart, UINT *puEpochEnd,
\par                                 int *pnError);
\par 
\par // Get the offset in the sampling sequence for the given physical channel.
\par BOOL WINAPI ABFH_GetChannelOffset( const ABFFileHeader *pFH, int nChannel, UINT *puChannelOffset );
\par 
\par // This function forms the de-multiplexed DAC output waveform for the
\par // particular channel in the pfBuffer, in DAC UserUnits.
\par BOOL WINAPI ABFH_GetWaveform( const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                               float *pfBuffer, int *pnError);
\par 
\par // This function forms the de-multiplexed Digital output waveform for the
\par // particular channel in the pdwBuffer, as a bit mask. Digital OUT 0 is in bit 0.
\par BOOL WINAPI ABFH_GetDigitalWaveform( const ABFFileHeader *pFH, int nChannel, DWORD dwEpisode, 
\par                                      DWORD *pdwBuffer, int *pnError);
\par 
\par // Returns vector pairs for displaying a waveform made up of epochs.
\par BOOL WINAPI ABFH_GetWaveformVector(const ABFFileHeader *pFH, DWORD dwEpisode, UINT uStart, 
\par                                    UINT uFinish, float *pfLevels, float *pfTimes,
\par                                    int *pnVectors, int *pnError);
\par 
\par // Returns vector pairs for displaying the digital outs.
\par BOOL WINAPI ABFH_GetDigitalWaveformVector(const ABFFileHeader *pFH, DWORD dwEpisode, UINT uStart, 
\par                                           UINT uFinish, DWORD *pdwLevels, float *pfTimes,
\par                                           int *pnVectors, int *pnError);
\par 
\par // Calculates the timebase array for the file.
\par void WINAPI ABFH_GetTimebase(const ABFFileHeader *pFH, float fTimeOffset, float *pfBuffer, UINT uBufferSize);
\par void WINAPI ABFH_GetTimebaseEx(const ABFFileHeader *pFH, double dTimeOffset, double *pdBuffer, UINT uBufferSize);
\par 
\par // Get the duration of the first holding period.
\par UINT WINAPI ABFH_GetHoldingDuration(const ABFFileHeader *pFH);
\par 
\par // Checks whether the waveform varies from episode to episode.
\par BOOL WINAPI ABFH_IsConstantWaveform(const ABFFileHeader *pFH);
\par 
\par // Checks that the sample intervals in the header are valid.
\par BOOL WINAPI ABFH_CheckSampleIntervals(const ABFFileHeader *pFH, float fClockResolution, int *pnError);
\par 
\par // Gets the closest sample intervals higher and lower than the passed interval.
\par void WINAPI ABFH_GetClosestSampleIntervals(float fSampleInterval, float fClockResolution, 
\par                                            int nOperationMode, float fMinPeriod, float fMaxPeriod,
\par                                            float *pfHigher, float *pfLower);
\par 
\par // Sets up the list for the spinner to drive the sampling interval through.
\par UINT WINAPI ABFH_SetupSamplingList(UINT uNumChannels, float fMinPeriod, float fMaxPeriod, 
\par                                    float *pfIntervalList, UINT uListEntries);
\par 
\par // Get the full sweep length given the length available to epochs or vice-versa.
\par int WINAPI ABFH_SweepLenFromUserLen(int nUserLength, int nNumChannels);
\par int WINAPI ABFH_UserLenFromSweepLen(int nSweepLength, int nNumChannels);
\par 
\par // Converts a display range to the equivalent gain and offset factors.
\par void WINAPI ABFH_GainOffsetToDisplayRange( const ABFFileHeader *pFH, int nChannel, 
\par                                            float fDisplayGain, float fDisplayOffset,
\par                                            float *pfUUTop, float *pfUUBottom);
\par 
\par // Converts a display range to the equivalent gain and offset factors.
\par void WINAPI ABFH_DisplayRangeToGainOffset( const ABFFileHeader *pFH, int nChannel, 
\par                                            float fUUTop, float fUUBottom,
\par                                            float *pfDisplayGain, float *pfDisplayOffset);
\par 
\par // Converts a time value to a synch time count or vice-versa.
\par void WINAPI ABFH_SynchCountToMS(const ABFFileHeader *pFH, UINT uCount, double *pdTimeMS);
\par UINT WINAPI ABFH_MSToSynchCount(const ABFFileHeader *pFH, double dTimeMS);
\par 
\par // Gets the point at which the sampling interval changes if split clock.
\par UINT WINAPI ABFH_GetClockChange(const ABFFileHeader *pFH);
\par 
\par // Gets the duration of the Waveform Episode (in us), allowing for split clock etc.
\par void WINAPI ABFH_GetEpisodeDuration(const ABFFileHeader *pFH, double *pdEpisodeDuration);
\par 
\par // Gets the duration of a P/N sequence (in us), including settling times.
\par void WINAPI ABFH_GetPNDuration(const ABFFileHeader *pFH, double *pdPNDuration);
\par 
\par // Gets the duration of a conditioning train in us.
\par void WINAPI ABFH_GetTrainDuration(const ABFFileHeader *pFH, double *pdTrainDuration);
\par 
\par // Gets the duration of a whole meta-episode (in us).
\par void WINAPI ABFH_GetMetaEpisodeDuration(const ABFFileHeader *pFH, double *pdMetaEpisodeDuration);
\par 
\par // Gets the start to start period for the episode in us.
\par void WINAPI ABFH_GetEpisodeStartToStart(const ABFFileHeader *pFH, double *pdEpisodeStartToStart);
\par 
\par // Checks that the user list contains valid entries for the protocol.
\par BOOL WINAPI ABFH_CheckUserList(const ABFFileHeader *pFH, int *pnError);
\par 
\par //
\par // Error return values that may be returned by the ABFH_xxx functions.
\par //
\par 
\par #define ABFH_FIRSTERRORNUMBER          2001
\par #define ABFH_EHEADERREAD               2001
\par #define ABFH_EHEADERWRITE              2002
\par #define ABFH_EINVALIDFILE              2003
\par #define ABFH_EUNKNOWNFILETYPE          2004
\par #define ABFH_CHANNELNOTSAMPLED         2005
\par #define ABFH_EPOCHNOTPRESENT           2006
\par #define ABFH_ENOWAVEFORM               2007
\par #define ABFH_EDACFILEWAVEFORM          2008
\par #define ABFH_ENOMEMORY                 2009
\par #define ABFH_BADSAMPLEINTERVAL         2010
\par #define ABFH_BADSECONDSAMPLEINTERVAL   2011
\par #define ABFH_BADSAMPLEINTERVALS        2012
\par #define ABFH_ENOCONDITTRAINS           2013
\par #define ABFH_EMETADURATION             2014
\par #define ABFH_ECONDITNUMPULSES          2015
\par #define ABFH_ECONDITBASEDUR            2016
\par #define ABFH_ECONDITBASELEVEL          2017
\par #define ABFH_ECONDITPOSTTRAINDUR       2018
\par #define ABFH_ECONDITPOSTTRAINLEVEL     2019
\par #define ABFH_ESTART2START              2020
\par #define ABFH_EINACTIVEHOLDING          2021
\par #define ABFH_EINVALIDCHARS             2022
\par #define ABFH_ENODIG                    2023
\par #define ABFH_EDIGHOLDLEVEL             2024
\par #define ABFH_ENOPNPULSES               2025
\par #define ABFH_EPNNUMPULSES              2026
\par #define ABFH_ENOEPOCH                  2027
\par #define ABFH_EEPOCHLEN                 2028
\par #define ABFH_EEPOCHINITLEVEL           2029
\par #define ABFH_EDIGLEVEL                 2030
\par #define ABFH_ECONDITSTEPDUR            2031
\par #define ABFH_ECONDITSTEPLEVEL          2032
\par #define ABFH_EINVALIDBINARYCHARS       2033
\par 
\par #ifdef __cplusplus
\par \}
\par #endif
\par 
\par #endif   /* INC_ABFHEADR_H */
\par }\pard\plain \s15\sb240\widctlpar\adjustright \b\f1\fs22\cgrid { See Also:
\par }\pard\plain \sb120\widctlpar\adjustright \f1\fs20\cgrid {\uldb\cf11 The ABF File I/O Functions}{\v The_ABF_File_I_O_Functions}{ 
{\v0\par\v}}{\uldb\cf11 The ABF File I/O Functions by category}{\v The_ABF_File_I_O_Functions_by_category}{ 
{\v0\par\v}}{\uldb\cf11 ABFFILES.H}{\v ABFFILES_H}{ 
{\v0\par\v}}{\uldb\cf11 ABFINFO.H}{\v ABFINFO_H}{ 
{\v0\par\v}
{\v0\par\v}}}
